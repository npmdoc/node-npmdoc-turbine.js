<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/wmbenedetto/turbine.js">turbine.js (v0.4.0)</a>
</h1>
<h4>Turbine.js is an event-driven JavaScript Workflow Engine.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.turbine.js">module turbine.js</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine">
            function <span class="apidocSignatureSpan">turbine.js.</span>Turbine
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.js.Turbine">
            function <span class="apidocSignatureSpan">turbine.js.</span>js.Turbine
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">turbine.js.</span>js.Turbine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">turbine.js.</span>js.Turbine.prototype.utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.turbine.js.Turbine">module turbine.js.Turbine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.Turbine">
            function <span class="apidocSignatureSpan">turbine.js.</span>Turbine
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.turbine.js.Turbine.prototype">module turbine.js.Turbine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clear">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clear
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clearAllQueryTimers">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearAllQueryTimers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clearDelayTimer">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearDelayTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clearGlobalTimer">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearGlobalTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clearQueryTimer">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearQueryTimer
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.clearTimers">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearTimers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.exec">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>exec
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getGlobalTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getGlobalTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getNextQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getNextQuery
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getResponse">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getResponse
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getShortcut">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getShortcut
            <span class="apidocSignatureSpan">(shortcut)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getStartingQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getStartingQuery
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getUsingObject">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getUsingObject
            <span class="apidocSignatureSpan">(using)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.getVar">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getVar
            <span class="apidocSignatureSpan">(varName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.handleIncomingMessage">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>handleIncomingMessage
            <span class="apidocSignatureSpan">(message, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.hasQueryFunction">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>hasQueryFunction
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importAlways">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importAlways
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importFunctions">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importFunctions
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importMixins">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importMixins
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importObjects">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importObjects
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importQueries">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importQueries
            <span class="apidocSignatureSpan">(workflow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importQuery
            <span class="apidocSignatureSpan">(query, workflow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importResponse">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importResponse
            <span class="apidocSignatureSpan">(response, query, workflow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importSequence">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importSequence
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importSequenceQueries">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importSequenceQueries
            <span class="apidocSignatureSpan">(sequence)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.importWorkflow">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importWorkflow
            <span class="apidocSignatureSpan">(initObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.initPubSub">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>initPubSub
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isDirtyQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isDirtyQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isEarlierQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isEarlierQuery
            <span class="apidocSignatureSpan">(nextQuery, currentQuery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isGlobalTimeoutAllowed">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isGlobalTimeoutAllowed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isKillQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isKillQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isKilled">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isKilled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isLoggable">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isLoggable
            <span class="apidocSignatureSpan">(level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isStarted">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStarted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isStopQuery">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStopQuery
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.isStopped">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStopped
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.kill">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>kill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.listen">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>listen
            <span class="apidocSignatureSpan">(message, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.log">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>log
            <span class="apidocSignatureSpan">(funcName, message, payload, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.next">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.onDelayTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onDelayTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.onGlobalTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onGlobalTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.onResponseTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onResponseTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.parseWaitFor">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>parseWaitFor
            <span class="apidocSignatureSpan">(waitFor, nextQuery, appendAlwaysWaitFor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.processResponse">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>processResponse
            <span class="apidocSignatureSpan">(query, response, preventGlobalTimeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.publish">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publish
            <span class="apidocSignatureSpan">(message, payload, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.publishAndWait">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publishAndWait
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.publishNow">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publishNow
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.queue">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>queue
            <span class="apidocSignatureSpan">(waitFor, nextQuery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.remove">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>remove
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.repeat">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>repeat
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.replace">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replace
            <span class="apidocSignatureSpan">(target, source, prepend, recursive, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.replaceMixins">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceMixins
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.replaceShortcuts">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceShortcuts
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.replaceVariables">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceVariables
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.report">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>report
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.reportIssueFromWorkflow">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>reportIssueFromWorkflow
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.resetResponse">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>resetResponse
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.rewind">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>rewind
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.setResponse">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>setResponse
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.setResponseTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>setResponseTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.start">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.startDelayTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>startDelayTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.startGlobalTimeout">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>startGlobalTimeout
            <span class="apidocSignatureSpan">(query, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.stop">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>DEFAULT_GLOBAL_TIMEOUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.turbine.js.Turbine.prototype.utils">module turbine.js.Turbine.prototype.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.utils.inArray">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>inArray
            <span class="apidocSignatureSpan">(item, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.utils.isArray">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.utils.isObjLiteral">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>isObjLiteral
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.utils.mergeObjects">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>mergeObjects
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.turbine.js.Turbine.prototype.utils.traverseObj">
            function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>traverseObj
            <span class="apidocSignatureSpan">(obj, depth, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.turbine.js" id="apidoc.module.turbine.js">module turbine.js</a></h1>


    <h2>
        <a href="#apidoc.element.turbine.js.Turbine" id="apidoc.element.turbine.js.Turbine">
        function <span class="apidocSignatureSpan">turbine.js.</span>Turbine
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Turbine(initObj) {

    if (typeof initObj !== 'object' || initObj === null){

        var errorMsg                        = 'Turbine constructor must be passed an initialization object';

        this.report({
            handle                          : 'INIT_OBJ_NOT_DEFINED',
            desc                            : errorMsg
        });

        throw new Error(errorMsg);
    }

    if (!MINIFIED){

        this.logLevels = {
            OFF                             : 0,
            ERROR                           : 1,
            WARN                            : 2,
            INFO                            : 3,
            DEBUG                           : 4,
            TRACE                           : 5
        };
    }

    this.always                             = {};
    this.alwaysWaitFor                      = {};
    this.currentQuery                       = null;
    this.dirtyQueries                       = {};
    this.globalTimeoutAllowed               = false;
    this.logLevel                           = initObj.logLevel  || 'ERROR';
    this.name                               = initObj.name      || 'Turbine';
    this.mixins                             = {};
    this.numGlobalListeners                 = 0;
    this.queries                            = {};
    this.queryOrder                         = [];
    this.resets                             = {};
    this.responses                          = {};
    this.shortcuts                          = {};
    this.started                            = false;
    this.killed                             = false;
    this.variables                          = {};
    this.waitingFor                         = null;
    this.workflow                           = {};

    this.timers = {
        queries                             : {},
        delay                               : null,
        global                              : null
    };

    this.initPubSub();
    this.importFunctions(initObj);
    this.importObjects(initObj);
    this.importAlways();
    this.importMixins();

    if (initObj.workflow) {

        this.importWorkflow(initObj);

    } else if (initObj.sequence) {

        this.importSequence(initObj);
    }

    if (typeof initObj.init === 'function'){
        initObj.init(this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.js.Turbine" id="apidoc.element.turbine.js.js.Turbine">
        function <span class="apidocSignatureSpan">turbine.js.</span>js.Turbine
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Turbine(initObj) {

    if (typeof initObj !== 'object' || initObj === null){

        var errorMsg                        = 'Turbine constructor must be passed an initialization object';

        this.report({
            handle                          : 'INIT_OBJ_NOT_DEFINED',
            desc                            : errorMsg
        });

        throw new Error(errorMsg);
    }

    if (!MINIFIED){

        this.logLevels = {
            OFF                             : 0,
            ERROR                           : 1,
            WARN                            : 2,
            INFO                            : 3,
            DEBUG                           : 4,
            TRACE                           : 5
        };
    }

    this.always                             = {};
    this.alwaysWaitFor                      = {};
    this.currentQuery                       = null;
    this.dirtyQueries                       = {};
    this.globalTimeoutAllowed               = false;
    this.logLevel                           = initObj.logLevel  || 'ERROR';
    this.name                               = initObj.name      || 'Turbine';
    this.mixins                             = {};
    this.numGlobalListeners                 = 0;
    this.queries                            = {};
    this.queryOrder                         = [];
    this.resets                             = {};
    this.responses                          = {};
    this.shortcuts                          = {};
    this.started                            = false;
    this.killed                             = false;
    this.variables                          = {};
    this.waitingFor                         = null;
    this.workflow                           = {};

    this.timers = {
        queries                             : {},
        delay                               : null,
        global                              : null
    };

    this.initPubSub();
    this.importFunctions(initObj);
    this.importObjects(initObj);
    this.importAlways();
    this.importMixins();

    if (initObj.workflow) {

        this.importWorkflow(initObj);

    } else if (initObj.sequence) {

        this.importSequence(initObj);
    }

    if (typeof initObj.init === 'function'){
        initObj.init(this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.turbine.js.Turbine" id="apidoc.module.turbine.js.Turbine">module turbine.js.Turbine</a></h1>


    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.Turbine" id="apidoc.element.turbine.js.Turbine.Turbine">
        function <span class="apidocSignatureSpan">turbine.js.</span>Turbine
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Turbine(initObj) {

    if (typeof initObj !== 'object' || initObj === null){

        var errorMsg                        = 'Turbine constructor must be passed an initialization object';

        this.report({
            handle                          : 'INIT_OBJ_NOT_DEFINED',
            desc                            : errorMsg
        });

        throw new Error(errorMsg);
    }

    if (!MINIFIED){

        this.logLevels = {
            OFF                             : 0,
            ERROR                           : 1,
            WARN                            : 2,
            INFO                            : 3,
            DEBUG                           : 4,
            TRACE                           : 5
        };
    }

    this.always                             = {};
    this.alwaysWaitFor                      = {};
    this.currentQuery                       = null;
    this.dirtyQueries                       = {};
    this.globalTimeoutAllowed               = false;
    this.logLevel                           = initObj.logLevel  || 'ERROR';
    this.name                               = initObj.name      || 'Turbine';
    this.mixins                             = {};
    this.numGlobalListeners                 = 0;
    this.queries                            = {};
    this.queryOrder                         = [];
    this.resets                             = {};
    this.responses                          = {};
    this.shortcuts                          = {};
    this.started                            = false;
    this.killed                             = false;
    this.variables                          = {};
    this.waitingFor                         = null;
    this.workflow                           = {};

    this.timers = {
        queries                             : {},
        delay                               : null,
        global                              : null
    };

    this.initPubSub();
    this.importFunctions(initObj);
    this.importObjects(initObj);
    this.importAlways();
    this.importMixins();

    if (initObj.workflow) {

        this.importWorkflow(initObj);

    } else if (initObj.sequence) {

        this.importSequence(initObj);
    }

    if (typeof initObj.init === 'function'){
        initObj.init(this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.turbine.js.Turbine.prototype" id="apidoc.module.turbine.js.Turbine.prototype">module turbine.js.Turbine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clear" id="apidoc.element.turbine.js.Turbine.prototype.clear">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clear
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (query) {

    if (!MINIFIED){
        this.log('clear', 'Clearing ' + query, null, 'DEBUG');
    }

    this.clearQueryTimer(query);

<span class="apidocCodeCommentSpan">    /* Reset counters for repeat queries */
</span>    for (var response in this.workflow[query]) {

        if (this.workflow[query].hasOwnProperty(response) &amp;&amp; this.workflow[query][response].repeat) {

            this.workflow[query][response].repeat.counter = 0;
        }
    }

    this.resetResponse(query);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var query                       = this.queryOrder[i];

        if (query === from) {
            clearing                    = true;
        }

        if (clearing) {
            this.<span class="apidocCodeKeywordSpan">clear</span>(query);
        }

        if (query === to) {
            break;
        }
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clearAllQueryTimers" id="apidoc.element.turbine.js.Turbine.prototype.clearAllQueryTimers">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearAllQueryTimers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearAllQueryTimers = function () {

    if (!MINIFIED){
        this.log('clearAllQueryTimers', 'Clearing all query timers', this.timers.queries, 'TRACE');
    }

    for (var query in this.timers.queries) {

        if (this.timers.queries.hasOwnProperty(query)) {

            this.clearQueryTimer(query);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
clearTimers : function() {

    if (!MINIFIED){
        this.log('clearTimers', 'Clearing all timers', this.timers, 'TRACE');
    }

    this.<span class="apidocCodeKeywordSpan">clearAllQueryTimers</span>();
    this.clearGlobalTimer();
    this.clearDelayTimer();
},

/**
 * Clears all timers for all queries
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clearDelayTimer" id="apidoc.element.turbine.js.Turbine.prototype.clearDelayTimer">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearDelayTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearDelayTimer = function () {

    if (this.timers.delay !== null) {

        if (!MINIFIED){
            this.log('clearDelayTimer', 'Clearing delay timer', this.timers.delay, 'TRACE');
        }

        clearTimeout(this.timers.delay);

        this.timers.delay               = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('clearTimers', 'Clearing all timers', this.timers, 'TRACE');
    }

    this.clearAllQueryTimers();
    this.clearGlobalTimer();
    this.<span class="apidocCodeKeywordSpan">clearDelayTimer</span>();
},

/**
 * Clears all timers for all queries
 */
clearAllQueryTimers : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clearGlobalTimer" id="apidoc.element.turbine.js.Turbine.prototype.clearGlobalTimer">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearGlobalTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearGlobalTimer = function () {

    if (this.timers.global !== null) {

        if (!MINIFIED){
            this.log('clearGlobalTimer', 'Clearing global timer', this.timers.global, 'TRACE');
        }

        clearTimeout(this.timers.global);

        this.timers.global              = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
clearTimers : function() {

    if (!MINIFIED){
        this.log('clearTimers', 'Clearing all timers', this.timers, 'TRACE');
    }

    this.clearAllQueryTimers();
    this.<span class="apidocCodeKeywordSpan">clearGlobalTimer</span>();
    this.clearDelayTimer();
},

/**
 * Clears all timers for all queries
 */
clearAllQueryTimers : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clearQueryTimer" id="apidoc.element.turbine.js.Turbine.prototype.clearQueryTimer">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearQueryTimer
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearQueryTimer = function (query) {

    var timerArray                      = this.timers.queries[query];

    if (timerArray) {

        if (!MINIFIED){
            this.log('clearQueryTimer', 'Clearing '+query+' query timer', this.timers.queries[query], 'TRACE');
        }

        for (var i=0;i&lt;timerArray.length;i++) {
            clearTimeout(timerArray[i]);
        }

        try {
            delete this.timers.queries[query];
        } catch (e) {
            this.timers.queries[query]  = undefined;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         */
        clear : function(query) {

            if (!MINIFIED){
                this.log('clear', 'Clearing ' + query, null, 'DEBUG');
            }

            this.<span class="apidocCodeKeywordSpan">clearQueryTimer</span>(query);

            /* Reset counters for repeat queries */
            for (var response in this.workflow[query]) {

                if (this.workflow[query].hasOwnProperty(response) &amp;&amp; this.workflow[query][response].repeat) {

this.workflow[query][response].repeat.counter = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.clearTimers" id="apidoc.element.turbine.js.Turbine.prototype.clearTimers">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>clearTimers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimers = function () {

    if (!MINIFIED){
        this.log('clearTimers', 'Clearing all timers', this.timers, 'TRACE');
    }

    this.clearAllQueryTimers();
    this.clearGlobalTimer();
    this.clearDelayTimer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /**
         * Executes a query
         *
         * @param query The query to execute
         */
        exec : function(query) {

this.<span class="apidocCodeKeywordSpan">clearTimers</span>();

if (this.isKillQuery(query)) {
    this.kill();
}

if (this.isStopQuery(query)) {
    this.stop();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.exec" id="apidoc.element.turbine.js.Turbine.prototype.exec">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>exec
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (query) {

    this.clearTimers();

    if (this.isKillQuery(query)) {
        this.kill();
    }

    if (this.isStopQuery(query)) {
        this.stop();
        return null;
    }

    if (this.isKilled()) {
        return null;
    }

    this.currentQuery                   = query;
    this.nextQuery                      = null;
    this.responses[query]               = this.getResponse(query);

<span class="apidocCodeCommentSpan">    /* If the query doesn't exist, we can't go any further */
</span>    if (!this.utils.isObjLiteral(this.workflow[query])) {

        this.report({
            handle                      : 'QUERY_DOES_NOT_EXIST',
            desc                        : '[' + this.name + '.exec()] ' + query + ' query does not exist'
        });

        return null;
    }

    var responseName                    = this.responses[query];
    var responseObj                     = this.workflow[query][responseName];

    /* If the response doesn't exist, check if a default response has been specified */
    if (!responseObj) {

        responseName                    = 'default';
        responseObj                     = this.workflow[query][responseName];

        /* If there's no default response specified either, then there's nothing else we can do */
        if (!responseObj) {

            this.report({
                handle                  : 'RESPONSE_DOES_NOT_EXIST',
                desc                    : '[' + this.name + '.exec()] ' + responseName + ' response does not exist for the ' + query
 + ' query'
            });

            return null;
        }
    }

    if (!MINIFIED){
        this.log('exec', 'Executing the ' + responseName + ' response to the ' + query + ' query', responseObj, 'DEBUG');
    }

    responseObj.responseName            = responseName;

    this.processResponse(query,responseObj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return null;
    }

    if (!MINIFIED){
        this.log('next', 'Executing next workflow query:', this.nextQuery, 'TRACE');
    }

    this.<span class="apidocCodeKeywordSpan">exec</span>(this.nextQuery);
},

/**
 * Executes a query
 *
 * @param query The query to execute
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getGlobalTimeout" id="apidoc.element.turbine.js.Turbine.prototype.getGlobalTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getGlobalTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getGlobalTimeout = function () {

    if (this.utils.isObjLiteral(this.always.timeout) &amp;&amp; typeof this.always.timeout.after !== 'undefined'){

        return this.always.timeout.after;

    } else {

        return this.DEFAULT_GLOBAL_TIMEOUT;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.clearGlobalTimer();

if (!MINIFIED){
    this.log('startGlobalTimeout', 'Starting global timer', this.always.timeout, 'TRACE');
}

var timeout                         = this.<span class="apidocCodeKeywordSpan">getGlobalTimeout</span>();
var self                            = this;

this.timers.global = setTimeout(function() {

    self.onGlobalTimeout(query,response);

},timeout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getNextQuery" id="apidoc.element.turbine.js.Turbine.prototype.getNextQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getNextQuery
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNextQuery = function (message) {

    var next                            = null;

    for (var msg in this.nextQueryObj) {

        if (this.nextQueryObj.hasOwnProperty(msg) &amp;&amp; message === msg) {
            next                        = this.nextQueryObj[msg];
            break;
        }
    }

    if (!MINIFIED){
        this.log('getNextQuery', 'Getting the next query: '+next, null, 'TRACE');
    }

    return next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.log('handleIncomingMessage', 'Handling "'+message+'" message', payload);
}

if (this.waitingFor) {

    this.remove(this.waitingFor);

    this.nextQuery                  = this.<span class="apidocCodeKeywordSpan">getNextQuery</span>(message);
}

this.waitingFor                     = null;

if (this.isEarlierQuery(this.nextQuery,this.currentQuery)){
    this.rewind(this.currentQuery,this.nextQuery);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getResponse" id="apidoc.element.turbine.js.Turbine.prototype.getResponse">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getResponse
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getResponse = function (query) {

    this.responses[query]               = (this.hasQueryFunction(query)) ? this.queries[query]() : this.responses[query];

<span class="apidocCodeCommentSpan">    /* Convert boolean result to yes/no string */
</span>    if (typeof this.responses[query] === 'boolean' || this.responses[query] === null || typeof this.responses[query] === 'undefined
') {
        this.responses[query]           = (this.responses[query]) ? 'yes' : 'no';
    }

    if (!MINIFIED){
        this.log('getResponse',query + '?', this.responses[query]);
    }

    return this.responses[query];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            if (this.isKilled()) {
return null;
            }

            this.currentQuery                   = query;
            this.nextQuery                      = null;
            this.responses[query]               = this.<span class="apidocCodeKeywordSpan">getResponse</span>(query);

            /* If the query doesn't exist, we can't go any further */
            if (!this.utils.isObjLiteral(this.workflow[query])) {

this.report({
    handle                      : 'QUERY_DOES_NOT_EXIST',
    desc                        : '[' + this.name + '.exec()] ' + query + ' query does not exist'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getShortcut" id="apidoc.element.turbine.js.Turbine.prototype.getShortcut">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getShortcut
        <span class="apidocSignatureSpan">(shortcut)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getShortcut = function (shortcut) {

<span class="apidocCodeCommentSpan">    /* Prepend @ symbol if not already there */
</span>    shortcut                            = (shortcut.indexOf('@') === 0) ? shortcut.substr(1) : shortcut;

    return (typeof this.shortcuts[shortcut] !== 'undefined') ? this.shortcuts[shortcut] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Gets the query with which to start the workflow. If a @start shortcut
 * is specified, that is used. Otherwise, the first query in the workflow is used.
 *
 * @return {String}
 */
getStartingQuery : function() {

    var start                           = this.<span class="apidocCodeKeywordSpan">getShortcut</span>('start');

    return (start) ? start : this.queryOrder[0];
},

/**
 * Queues query to be executed on next message
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getStartingQuery" id="apidoc.element.turbine.js.Turbine.prototype.getStartingQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getStartingQuery
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getStartingQuery = function () {

    var start                           = this.getShortcut('start');

    return (start) ? start : this.queryOrder[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('start', 'Starting Turbine');
    }

    this.started                        = true;

    this.queue(null,this.<span class="apidocCodeKeywordSpan">getStartingQuery</span>());
    this.next();
},

/**
 * Stops Turbine
 */
stop : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getUsingObject" id="apidoc.element.turbine.js.Turbine.prototype.getUsingObject">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getUsingObject
        <span class="apidocSignatureSpan">(using)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUsingObject = function (using) {

    using                               = (typeof using === 'undefined') ? {} : using;

<span class="apidocCodeCommentSpan">    /* If an always.using object has been defined, merge it into the response's using object */
</span>    if (this.always.using) {
        using                           = this.utils.mergeObjects(using,this.always.using);
    }

    if (!MINIFIED){
        this.log('getUsingObject', 'Getting using object', using, 'TRACE');
    }

    return using;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var message                         = null;
var using                           = {};

if (this.utils.isObjLiteral(response.publish)) {

    message                         = response.publish.message;
    using                           = this.<span class="apidocCodeKeywordSpan">getUsingObject</span>(response.publish.using);

} else {

    message                         = response.publish;
}

this.publish(message,using);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.getVar" id="apidoc.element.turbine.js.Turbine.prototype.getVar">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>getVar
        <span class="apidocSignatureSpan">(varName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVar = function (varName) {

<span class="apidocCodeCommentSpan">    /* Prepend dollar sign if not already there */
</span>    varName                             = (varName.indexOf('$') === 0) ? varName.substr(1) : varName;

    return (typeof this.variables[varName] !== 'undefined') ? this.variables[varName] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.setResponse('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.start()] Starting Turbine\r\n[CartExample.publish()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.stop();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.<span class="apidocCodeKeywordSpan">getVar</span>('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.handleIncomingMessage" id="apidoc.element.turbine.js.Turbine.prototype.handleIncomingMessage">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>handleIncomingMessage
        <span class="apidocSignatureSpan">(message, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleIncomingMessage = function (message, payload) {

    if (this.isKilled()) {
        return null;
    }

    if (!MINIFIED){
        this.log('handleIncomingMessage', 'Handling "'+message+'" message', payload);
    }

    if (this.waitingFor) {

        this.remove(this.waitingFor);

        this.nextQuery                  = this.getNextQuery(message);
    }

    this.waitingFor                     = null;

    if (this.isEarlierQuery(this.nextQuery,this.currentQuery)){
        this.rewind(this.currentQuery,this.nextQuery);
    }

    if (!this.isKilled()){
        this.next();
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assertTrue('delay timer var holds timer number',typeof turbine.timers.delay === 'number');
    },

    testHandleIncomingMessage : function(){

var turbine = new Turbine(this.initObj);

turbine.<span class="apidocCodeKeywordSpan">handleIncomingMessage</span>(this.workflow.config.always.waitFor[0].waitFor[0]);

assertTrue('next query is "then" query corresponding to global listener waitFor message',turbine.nextQuery ===
this.workflow.config.always.waitFor[0].then);
assertTrue('waitingFor is null',turbine.waitingFor === null);

turbine.stop();

var result = turbine.handleIncomingMessage(this.workflow.config.always.waitFor[0].waitFor[0]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.hasQueryFunction" id="apidoc.element.turbine.js.Turbine.prototype.hasQueryFunction">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>hasQueryFunction
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasQueryFunction = function (query) {
    return typeof this.queries[query] === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /**
         * Gets the response to a query
         *
         * @param query The query for which to get the response
         */
        getResponse : function(query) {

this.responses[query]               = (this.<span class="apidocCodeKeywordSpan">hasQueryFunction</span>(query)) ? this.queries[query
]() : this.responses[query];

/* Convert boolean result to yes/no string */
if (typeof this.responses[query] === 'boolean' || this.responses[query] === null || typeof this.responses[query] === &amp;#
x27;undefined') {
    this.responses[query]           = (this.responses[query]) ? 'yes' : 'no';
}

if (!MINIFIED){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importAlways" id="apidoc.element.turbine.js.Turbine.prototype.importAlways">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importAlways
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importAlways = function () {

    if (!MINIFIED){
        this.log('importAlways', 'Importing always', this.always, 'DEBUG');
    }

    if (typeof this.always.waitFor !== 'undefined'){

        this.replaceShortcuts(this.always.waitFor);
        this.replaceVariables(this.always.waitFor);

        var result                      = this.parseWaitFor(this.always.waitFor);

        this.alwaysWaitFor              = result.nextQueryObj;
        this.numAlwaysWaitFor           = result.waitingFor.length;

        if (!MINIFIED){
            this.log('importAlways', 'Always wait for', this.alwaysWaitFor, 'DEBUG');
        }
    }

<span class="apidocCodeCommentSpan">    /* If a global timeout is specified then global timeouts are allowed by default */
</span>    this.globalTimeoutAllowed           = typeof this.always.timeout !== 'undefined';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delay                               : null,
    global                              : null
};

this.initPubSub();
this.importFunctions(initObj);
this.importObjects(initObj);
this.<span class="apidocCodeKeywordSpan">importAlways</span>();
this.importMixins();

if (initObj.workflow) {

    this.importWorkflow(initObj);

} else if (initObj.sequence) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importFunctions" id="apidoc.element.turbine.js.Turbine.prototype.importFunctions">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importFunctions
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importFunctions = function (initObj) {

    if (!MINIFIED){
        this.log('importFunctions', 'Importing functions', null, 'DEBUG');
    }

    var thisFunc                        = null;
    var importedFunctions               = {};
    var validFunctions = [
        'init',
        'log',
        'publish',
        'listen',
        'remove',
        'report'
    ];

    for (var i=0;i&lt;validFunctions.length;i++) {

        thisFunc                        = validFunctions[i];

        if (!MINIFIED){
            this.log('importFunctions', '--&gt; Importing ' + thisFunc + '() function', null, 'DEBUG');
        }

        if (typeof initObj[thisFunc] === 'function') {

            this[thisFunc]              = initObj[thisFunc];

            importedFunctions[thisFunc] = true;
        }
    }

    if (!$ &amp;&amp; (!('publish' in importedFunctions) || !('listen' in importedFunctions) || !('remove' in importedFunctions))) {

        var errorMsg                    = '[' + this.name + '.importFunctions()] You must either define publish(), listen(), and
 remove() functions via the initObj passed to the Turbine constructor, or you must include jQuery in the page.';

        this.report({
            handle                      : 'REQUIRED_FUNCTIONS_NOT_DEFINED',
            desc                        : errorMsg
        });

        throw new Error(errorMsg);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.timers = {
queries                             : {},
delay                               : null,
global                              : null
        };

        this.initPubSub();
        this.<span class="apidocCodeKeywordSpan">importFunctions</span>(initObj);
        this.importObjects(initObj);
        this.importAlways();
        this.importMixins();

        if (initObj.workflow) {

this.importWorkflow(initObj);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importMixins" id="apidoc.element.turbine.js.Turbine.prototype.importMixins">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importMixins
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importMixins = function (){

    if (!MINIFIED){
        this.log('importMixins', 'Importing mixins', this.mixins, 'DEBUG');
    }

    for (var mixin in this.mixins){

        if (this.mixins.hasOwnProperty(mixin)){
            this.replaceMixins(this.mixins[mixin]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    global                              : null
};

this.initPubSub();
this.importFunctions(initObj);
this.importObjects(initObj);
this.importAlways();
this.<span class="apidocCodeKeywordSpan">importMixins</span>();

if (initObj.workflow) {

    this.importWorkflow(initObj);

} else if (initObj.sequence) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importObjects" id="apidoc.element.turbine.js.Turbine.prototype.importObjects">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importObjects
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importObjects = function (initObj) {

    if (!MINIFIED){
        this.log('importObjects', 'Importing objects', null, 'DEBUG');
    }

    var thisObj                         = null;
    var validObjects = [
        'queries',
        'resets',
        'responses',
        'shortcuts',
        'variables',
        'always',
        'mixins'
    ];

    for (var i=0;i&lt;validObjects.length;i++) {

        thisObj                         = validObjects[i];

        if (!MINIFIED){
            this.log('importObjects', '--&gt; Importing ' + thisObj + ' object', null, 'DEBUG');
        }

        if (this.utils.isObjLiteral(initObj[thisObj])) {
            this[thisObj]               = initObj[thisObj];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queries                             : {},
delay                               : null,
global                              : null
        };

        this.initPubSub();
        this.importFunctions(initObj);
        this.<span class="apidocCodeKeywordSpan">importObjects</span>(initObj);
        this.importAlways();
        this.importMixins();

        if (initObj.workflow) {

this.importWorkflow(initObj);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importQueries" id="apidoc.element.turbine.js.Turbine.prototype.importQueries">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importQueries
        <span class="apidocSignatureSpan">(workflow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importQueries = function (workflow) {

    if (!MINIFIED){
        this.log('importQueries', 'Importing queries', workflow, 'DEBUG');
    }

    var totalQueries                    = 0;

<span class="apidocCodeCommentSpan">    /* Imports each query in the workflow */
</span>    for (var query in workflow) {

        if (workflow.hasOwnProperty(query)) {

            this.importQuery(query,workflow);

            totalQueries               += 1;
        }
    }

    if (totalQueries === 0) {

        var errorMsg                    = '[' + this.name + '.importQueries()] The workflow has no queries to import';

        this.report({
            handle                      : 'NO_QUERIES_TO_IMPORT',
            desc                        : errorMsg
        });

        throw new Error(errorMsg);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

this.workflow                       = initObj.workflow || {};

this.replaceMixins(this.workflow);

if (this.utils.isObjLiteral(initObj.workflow)) {
    this.<span class="apidocCodeKeywordSpan">importQueries</span>(initObj.workflow);
}

            } else {

var errorMsg                    = '[' + this.name + '.importWorkflow()] Could not import workflow. Workflow must
be an object literal.';

this.report({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importQuery" id="apidoc.element.turbine.js.Turbine.prototype.importQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importQuery
        <span class="apidocSignatureSpan">(query, workflow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importQuery = function (query, workflow) {

    if (!MINIFIED){
        this.log('importQuery', 'Importing workflow query: ' + query, workflow[query], 'TRACE');
    }

    this.queries[query]                 = this.queries[query] || null;

<span class="apidocCodeCommentSpan">    /* Store queries in array so they can be accessed numerically */
</span>    this.queryOrder.push(query);

    this.replaceMixins(query);

    for (var response in workflow[query]) {

        if (workflow[query].hasOwnProperty(response)) {
            this.importResponse(response,query,workflow);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var totalQueries                    = 0;

/* Imports each query in the workflow */
for (var query in workflow) {

    if (workflow.hasOwnProperty(query)) {

        this.<span class="apidocCodeKeywordSpan">importQuery</span>(query,workflow);

        totalQueries               += 1;
    }
}

if (totalQueries === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importResponse" id="apidoc.element.turbine.js.Turbine.prototype.importResponse">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importResponse
        <span class="apidocSignatureSpan">(response, query, workflow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importResponse = function (response, query, workflow) {

    var thisResponse                    = workflow[query][response];

    if (!MINIFIED){
        this.log('importResponse', 'Importing ' + response + ' response to ' + query + ' query', thisResponse, 'TRACE');
    }

<span class="apidocCodeCommentSpan">    /* Add counter to any repeat object */
</span>    if (thisResponse.repeat) {
        thisResponse.repeat.counter = 0;
    }

    this.replaceShortcuts(thisResponse);
    this.replaceVariables(thisResponse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.queryOrder.push(query);

    this.replaceMixins(query);

    for (var response in workflow[query]) {

        if (workflow[query].hasOwnProperty(response)) {
            this.<span class="apidocCodeKeywordSpan">importResponse</span>(response,query,workflow);
        }
    }
},

/**
 * Imports one response for one workflow query
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importSequence" id="apidoc.element.turbine.js.Turbine.prototype.importSequence">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importSequence
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSequence = function (initObj) {

    if (this.utils.isArray(initObj.sequence)) {

        if (!MINIFIED){
            this.log('importSequence', 'Importing sequence', null, 'DEBUG');
        }

        initObj.sequence                = initObj.sequence || [];
        initObj.workflow                = this.importSequenceQueries(initObj.sequence);
        initObj.sequence                = null;

        this.importWorkflow(initObj);

    } else {

        var errorMsg                    = '[' + this.name + '.importSequence()] Could not import sequence. Sequence must be an array
.';

        this.report({
            handle                      : 'COULD_NOT_IMPORT_SEQUENCE',
            desc                        : errorMsg
        });

        throw new Error(errorMsg);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (initObj.workflow) {

        this.importWorkflow(initObj);

    } else if (initObj.sequence) {

        this.<span class="apidocCodeKeywordSpan">importSequence</span>(initObj);
    }

    if (typeof initObj.init === 'function'){
        initObj.init(this);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importSequenceQueries" id="apidoc.element.turbine.js.Turbine.prototype.importSequenceQueries">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importSequenceQueries
        <span class="apidocSignatureSpan">(sequence)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSequenceQueries = function (sequence) {

    var workflow                        = {};
    var len                             = sequence.length;
    var self                            = this;
    var stepBaseName                    = 'SEQUENCE_STEP_';

<span class="apidocCodeCommentSpan">    /* Create regular workflow object from sequence array */
</span>    for (var i=0;i&lt;len;i++) {

        var query                       = sequence[i];
        var currentStepCount            = i + 1;

        (function(q,c){

            /* Rewrite every instance of "then" in the query objects */
            self.utils.traverseObj(q, 0, function(obj, item) {

                /* Replace "@next" with the name of the next query (or with "stop." if it's the last query) */
                if (item === 'then' &amp;&amp; obj[item] === '@next') {
                    var nextStepCount   = c + 1;
                    obj[item]           = (nextStepCount &gt; sequence.length) ? 'stop.' : stepBaseName + nextStepCount;
                }
            });

        }(query,currentStepCount));


        /* Name all queries in sequence as "SEQUENCE_STEP_1", "SEQUENCE_STEP_2", etc.
         * Only the "default" response body is needed since all query responses default to "default" */
        workflow[stepBaseName + currentStepCount]    = { default : query };
    }

    return workflow;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (this.utils.isArray(initObj.sequence)) {

if (!MINIFIED){
    this.log('importSequence', 'Importing sequence', null, 'DEBUG');
}

initObj.sequence                = initObj.sequence || [];
initObj.workflow                = this.<span class="apidocCodeKeywordSpan">importSequenceQueries</span>(initObj.sequence);
initObj.sequence                = null;

this.importWorkflow(initObj);

            } else {

var errorMsg                    = '[' + this.name + '.importSequence()] Could not import sequence. Sequence must
be an array.';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.importWorkflow" id="apidoc.element.turbine.js.Turbine.prototype.importWorkflow">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>importWorkflow
        <span class="apidocSignatureSpan">(initObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importWorkflow = function (initObj) {

    if (this.utils.isObjLiteral(initObj.workflow)) {

        if (!MINIFIED){
            this.log('importWorkflow', 'Importing workflow', null, 'DEBUG');
        }

        this.workflow                       = initObj.workflow || {};

        this.replaceMixins(this.workflow);

        if (this.utils.isObjLiteral(initObj.workflow)) {
            this.importQueries(initObj.workflow);
        }

    } else {

        var errorMsg                    = '[' + this.name + '.importWorkflow()] Could not import workflow. Workflow must be an object
 literal.';

        this.report({
            handle                      : 'COULD_NOT_IMPORT_WORKFLOW',
            desc                        : errorMsg
        });

        throw new Error(errorMsg);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.importFunctions(initObj);
this.importObjects(initObj);
this.importAlways();
this.importMixins();

if (initObj.workflow) {

    this.<span class="apidocCodeKeywordSpan">importWorkflow</span>(initObj);

} else if (initObj.sequence) {

    this.importSequence(initObj);
}

if (typeof initObj.init === 'function'){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.initPubSub" id="apidoc.element.turbine.js.Turbine.prototype.initPubSub">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>initPubSub
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initPubSub = function (){

    var self                            = this;

    this.pubsub = {

        publish : function(message,payload){
            $(self).trigger(message,payload);
        },

        listen : function(message,handler){
            $(self).on(message,function(e) {
                handler(e.type, e.data);
            });
        },

        remove : function(message){
            $(self).unbind(message);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.timers = {
    queries                             : {},
    delay                               : null,
    global                              : null
};

this.<span class="apidocCodeKeywordSpan">initPubSub</span>();
this.importFunctions(initObj);
this.importObjects(initObj);
this.importAlways();
this.importMixins();

if (initObj.workflow) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isDirtyQuery" id="apidoc.element.turbine.js.Turbine.prototype.isDirtyQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isDirtyQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirtyQuery = function (query){
    return this.dirtyQueries[query] === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * Resets the response to a query
         *
         * @param query The query for which the response should be reset
         */
        resetResponse : function(query) {

/* If the query is dirty, just clear the dirty flag. Don't reset the response. */
if (this.<span class="apidocCodeKeywordSpan">isDirtyQuery</span>(query)){

    this.dirtyQueries[query]        = null;

}
/* If the query isn't dirty, reset the response */
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isEarlierQuery" id="apidoc.element.turbine.js.Turbine.prototype.isEarlierQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isEarlierQuery
        <span class="apidocSignatureSpan">(nextQuery, currentQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEarlierQuery = function (nextQuery, currentQuery) {

    if (currentQuery === nextQuery) {
        return false;
    }

    for (var i=0;i&lt;this.queryOrder.length;i++) {

        if (this.queryOrder[i] === nextQuery) {
            return true;
        }

        if (this.queryOrder[i] === currentQuery) {
            return false;
        }
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this.queue(response.waitFor,response.then);

}
/* Otherwise, "then" query gets executed immediately */
else if (response.then){

    if (this.<span class="apidocCodeKeywordSpan">isEarlierQuery</span>(response.then,this.currentQuery)){
        this.rewind(this.currentQuery,response.then);
    }

    this.exec(response.then);
}

/* Clean up isPublishCallback flag */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isGlobalTimeoutAllowed" id="apidoc.element.turbine.js.Turbine.prototype.isGlobalTimeoutAllowed">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isGlobalTimeoutAllowed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isGlobalTimeoutAllowed = function () {
    return this.globalTimeoutAllowed === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         *
         * @param query The active query when the timeout is set
         * @param response The response being processed
         * @return {Boolean}
         */
        startGlobalTimeout : function(query,response) {

if (!this.<span class="apidocCodeKeywordSpan">isGlobalTimeoutAllowed</span>()) {
    return false;
}

this.clearGlobalTimer();

if (!MINIFIED){
    this.log('startGlobalTimeout', 'Starting global timer', this.always.timeout, 'TRACE');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isKillQuery" id="apidoc.element.turbine.js.Turbine.prototype.isKillQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isKillQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isKillQuery = function (query) {
    return query === 'kill!'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         *
         * @param query The query to execute
         */
        exec : function(query) {

this.clearTimers();

if (this.<span class="apidocCodeKeywordSpan">isKillQuery</span>(query)) {
    this.kill();
}

if (this.isStopQuery(query)) {
    this.stop();
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isKilled" id="apidoc.element.turbine.js.Turbine.prototype.isKilled">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isKilled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isKilled = function () {
    return this.killed === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        },

        /**
         * Starts Turbine by executing the first queued query
         */
        start : function() {

if (this.<span class="apidocCodeKeywordSpan">isKilled</span>()){

    if (!MINIFIED){
        this.log('start', 'Cannot start Turbine. It has already been killed.', null, 'ERROR');
    }

    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isLoggable" id="apidoc.element.turbine.js.Turbine.prototype.isLoggable">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isLoggable
        <span class="apidocSignatureSpan">(level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLoggable = function (level){

    if (!MINIFIED){
        return this.logLevels[level] &lt;= this.logLevels[this.logLevel];
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        log : function(funcName,message,payload,level) {

            if (!MINIFIED){
                payload                         = (!payload) ? '' : payload;
                level                           = (!level) ? 'INFO' : level;
                message                         = '[' + this.name + '.' + funcName + '()] ' + message
;

                if (this.<span class="apidocCodeKeywordSpan">isLoggable</span>(level)) {

                    switch (level){

case 'ERROR':
    console.error(message,payload);
    break;
case 'WARN':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isStarted" id="apidoc.element.turbine.js.Turbine.prototype.isStarted">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStarted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStarted = function (){
    return this.started === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.setResponse('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.start()] Starting Turbine\r\n[CartExample.publish()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.<span class="apidocCodeKeywordSpan">isStarted</span>(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.stop();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.getVar('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isStopQuery" id="apidoc.element.turbine.js.Turbine.prototype.isStopQuery">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStopQuery
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStopQuery = function (query) {
    return query === 'stop.'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.clearTimers();

if (this.isKillQuery(query)) {
    this.kill();
}

if (this.<span class="apidocCodeKeywordSpan">isStopQuery</span>(query)) {
    this.stop();
    return null;
}

if (this.isKilled()) {
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.isStopped" id="apidoc.element.turbine.js.Turbine.prototype.isStopped">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>isStopped
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStopped = function () {
    return this.started !== true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assertFalse('"other" is not stop query',turbine.isStopQuery('other'));
},

testIsStopped : function(){

    var turbine = new Turbine(this.initObj);

    assertFalse('Turbine is not stopped by default',turbine.<span class="apidocCodeKeywordSpan">isStopped</span>());

    turbine.stopped = true;

    assertTrue('Turbine is stopped',turbine.isStopped());
},

testIsGlobalTimeoutAllowed : function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.kill" id="apidoc.element.turbine.js.Turbine.prototype.kill">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>kill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kill = function (){

    if (!MINIFIED){
        this.log('kill', 'Killing Turbine');
    }

    this.started                        = false;
    this.killed                         = true;

    this.rewind();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * @param query The query to execute
         */
        exec : function(query) {

this.clearTimers();

if (this.isKillQuery(query)) {
    this.<span class="apidocCodeKeywordSpan">kill</span>();
}

if (this.isStopQuery(query)) {
    this.stop();
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.listen" id="apidoc.element.turbine.js.Turbine.prototype.listen">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>listen
        <span class="apidocSignatureSpan">(message, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function (message, handler) {

    if (!MINIFIED){
        this.log('listen', 'Adding listener for:', message, 'TRACE');
    }

    if (typeof message === 'string') {
        message                         = [message];
    }

    for (var i=0;i&lt;message.length;i++) {
        this.pubsub.listen(message[i],handler);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (typeof message === 'string') {
        message                         = [message];
    }

    for (var i=0;i&lt;message.length;i++) {
        this.pubsub.<span class="apidocCodeKeywordSpan">listen</span>(message[i],handler);
    }
},

/**
 * Default implementation of remove() method, using jQuery's unbind() function
 * to unbind handlers from messages.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.log" id="apidoc.element.turbine.js.Turbine.prototype.log">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>log
        <span class="apidocSignatureSpan">(funcName, message, payload, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (funcName, message, payload, level) {

    if (!MINIFIED){
        payload                         = (!payload) ? '' : payload;
        level                           = (!level) ? 'INFO' : level;
        message                         = '[' + this.name + '.' + funcName + '()] ' + message;

        if (this.isLoggable(level)) {

            switch (level){

                case 'ERROR':
                    console.error(message,payload);
                    break;
                case 'WARN':
                    console.warn(message,payload);
                    break;
                case 'INFO':
                    console.info(message,payload);
                    break;
                default:
                    console.log(message,payload);
                    break;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * Imports valid functions specified in initObj to Turbine
         *
         * @param initObj Initialization object
         */
        importFunctions : function(initObj) {

if (!MINIFIED){
    this.<span class="apidocCodeKeywordSpan">log</span>('importFunctions', 'Importing functions', null, '
;DEBUG');
}

var thisFunc                        = null;
var importedFunctions               = {};
var validFunctions = [
    'init',
    'log',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.next" id="apidoc.element.turbine.js.Turbine.prototype.next">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {

    if (this.isKilled() || this.nextQuery === null) {
        return null;
    }

    if (!MINIFIED){
        this.log('next', 'Executing next workflow query:', this.nextQuery, 'TRACE');
    }

    this.exec(this.nextQuery);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!MINIFIED){
        this.log('start', 'Starting Turbine');
    }

    this.started                        = true;

    this.queue(null,this.getStartingQuery());
    this.<span class="apidocCodeKeywordSpan">next</span>();
},

/**
 * Stops Turbine
 */
stop : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.onDelayTimeout" id="apidoc.element.turbine.js.Turbine.prototype.onDelayTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onDelayTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onDelayTimeout = function (query, response) {

    if (!MINIFIED){
        this.log('onDelayTimeout',query + ' delay completed after ' + response.delay.for + ' ms', response);
    }

    this.processResponse(query,response.delay);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.log('startDelayTimeout',query + ' delay started. Delayed for ' + response.delay.for + ' ms
', response);
    }

    var self                            = this;

    this.timers.delay = setTimeout(function() {

        self.<span class="apidocCodeKeywordSpan">onDelayTimeout</span>(query,response);

    },response.delay.for);
},

/**
 * Callback executed when delay timer expires
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.onGlobalTimeout" id="apidoc.element.turbine.js.Turbine.prototype.onGlobalTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onGlobalTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onGlobalTimeout = function (query, response) {

    if (this.waitingFor) {
        this.remove(this.waitingFor);
    }

    if (!MINIFIED){
        this.log('onGlobalTimeout', 'Turbine timed out on ' + query + ' query after ' + this.getGlobalTimeout() + ' ms',null,'ERROR
');
    }

<span class="apidocCodeCommentSpan">    /* Set flag so timeout isn't triggered again during reprocessing */
</span>    this.always.timeout.isAfterTimeout  = true;

    this.processResponse(null,this.always.timeout,true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var timeout                         = this.getGlobalTimeout();
    var self                            = this;

    this.timers.global = setTimeout(function() {

        self.<span class="apidocCodeKeywordSpan">onGlobalTimeout</span>(query,response);

    },timeout);

    return true;
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.onResponseTimeout" id="apidoc.element.turbine.js.Turbine.prototype.onResponseTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>onResponseTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onResponseTimeout = function (query, response) {

    if (!MINIFIED){
        this.log('onResponseTimeout', 'The ' + query + ' response timed out.', response, 'WARN');
    }

    if (this.waitingFor) {
        this.remove(this.waitingFor);
    }

<span class="apidocCodeCommentSpan">    /* Set flag so timeout isn't triggered again during reprocessing */
</span>    response.timeout.isAfterTimeout     = true;

    this.processResponse(query,response.timeout,true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.timers.queries[query]      = [];
    }

    var self                            = this;

    var timeout = setTimeout(function() {

        self.<span class="apidocCodeKeywordSpan">onResponseTimeout</span>(query,response);

    },response.timeout.after);

    this.timers.queries[query].push(timeout);
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.parseWaitFor" id="apidoc.element.turbine.js.Turbine.prototype.parseWaitFor">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>parseWaitFor
        <span class="apidocSignatureSpan">(waitFor, nextQuery, appendAlwaysWaitFor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWaitFor = function (waitFor, nextQuery, appendAlwaysWaitFor) {

    var waitingFor                      = [];
    var nextQueryObj                    = {};

    if (waitFor){

<span class="apidocCodeCommentSpan">        /* waitFor is a single message, so we map it to nextQuery */
</span>        if (typeof waitFor === 'string'){

            waitingFor.push(waitFor);
            nextQueryObj[waitFor] = nextQuery;

        } else {

            if (this.utils.isObjLiteral(waitFor)) {
                waitFor                 = [waitFor];
            }

            for (var j=0;j&lt;waitFor.length;j++){

                if (typeof waitFor[j] === 'string'){

                    waitingFor.push(waitFor[j]);
                    nextQueryObj[waitFor[j]] = nextQuery;

                } else if (typeof waitFor[j].message !== 'undefined'){

                    if (this.utils.isArray(waitFor[j].message)){

                        for (var k=0;k&lt;waitFor[j].message.length;k++){
                            waitingFor.push(waitFor[j].message[k]);
                            nextQueryObj[waitFor[j].message[k]] = waitFor[j].then || nextQuery;
                        }

                    } else {

                        waitingFor.push(waitFor[j].message);
                        nextQueryObj[waitFor[j].message] = waitFor[j].then || nextQuery;
                    }
                }
            }
        }
    }

    /* Add global listeners to waitingFor array, if they're not already there */
    if (appendAlwaysWaitFor){

        for (var msg in this.alwaysWaitFor) {

            if (this.alwaysWaitFor.hasOwnProperty(msg)) {

                waitingFor.push(msg);
                nextQueryObj[msg] = this.alwaysWaitFor[msg] || nextQuery;
            }
        }
    }

    return {
        waitingFor   : waitingFor,
        nextQueryObj : nextQueryObj
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }

            if (typeof this.always.waitFor !== 'undefined'){

this.replaceShortcuts(this.always.waitFor);
this.replaceVariables(this.always.waitFor);

var result                      = this.<span class="apidocCodeKeywordSpan">parseWaitFor</span>(this.always.waitFor);

this.alwaysWaitFor              = result.nextQueryObj;
this.numAlwaysWaitFor           = result.waitingFor.length;

if (!MINIFIED){
    this.log('importAlways', 'Always wait for', this.alwaysWaitFor, 'DEBUG');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.processResponse" id="apidoc.element.turbine.js.Turbine.prototype.processResponse">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>processResponse
        <span class="apidocSignatureSpan">(query, response, preventGlobalTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processResponse = function (query, response, preventGlobalTimeout) {

    this.clearTimers();

    if (this.isKilled()) {
        return null;
    }

    if (!MINIFIED){
        this.log('processResponse', 'Processing response to '+query+' query', response, 'TRACE');
    }

    if (!preventGlobalTimeout) {
        this.startGlobalTimeout(query,response);
    }

    if (response.delay &amp;&amp; !response.isAfterDelay) {

        this.startDelayTimeout(query,response);

    } else {

<span class="apidocCodeCommentSpan">        /* "report" tells us to report an issue. We only want to report it once, so
         * we ignore it if we're processing the response as part of a publish callback */
</span>        if (response.report &amp;&amp; !response.isPublishCallback) {
            this.reportIssueFromWorkflow(query,response);
        }

        /* If we have "publish" with no "waitFor", then just publish the message and move on */
        if (response.publish &amp;&amp; !response.waitFor &amp;&amp; !response.isPublishCallback) {

            this.publishNow(query,response);
        }

        /* If we have "publish" with "waitFor", then publish the message and wait for a response
         * before continuing. */
        if (response.publish &amp;&amp; response.waitFor &amp;&amp; !response.isPublishCallback) {

            this.publishAndWait(query,response);

        } else {

            if (response.repeat) {

                /* Clean up isAfterDelay flag */
                if (response.isAfterDelay) {

                    try {
                        delete response.isAfterDelay;
                    } catch (e) {
                        response.isAfterDelay       = undefined;
                    }
                }

                /* "repeat" repeats query */
                this.repeat(query,response);

            }
            /* "waitFor" tells us to wait for a message (or messages) before executing "then" query */
            else if (response.waitFor) {

                this.queue(response.waitFor,response.then);

            }
            /* Otherwise, "then" query gets executed immediately */
            else if (response.then){

                if (this.isEarlierQuery(response.then,this.currentQuery)){
                    this.rewind(this.currentQuery,response.then);
                }

                this.exec(response.then);
            }

            /* Clean up isPublishCallback flag */
            if (response.isPublishCallback) {

                try {
                    delete response.isPublishCallback;
                } catch (e) {
                    response.isPublishCallback  = undefined;
                }
            }

            /* If this response has a timeout, set the timer */
            if (response.timeout) {
                this.setResponseTimeout(query,response);
            }

            /* Clean up isAfterDelay flag */
            if (response.isAfterDelay) {

                try {
                    delete response.isAfterDelay;
                } catch (e) {
                    response.isAfterDelay       = undefined;
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('exec', 'Executing the ' + responseName + ' response to the ' + query + ' query
', responseObj, 'DEBUG');
    }

    responseObj.responseName            = responseName;

    this.<span class="apidocCodeKeywordSpan">processResponse</span>(query,responseObj);
},

/**
 * Processes a query's response, executing its the workflow logic
 *
 * @param query The query containing the response to process
 * @param response The response to process
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.publish" id="apidoc.element.turbine.js.Turbine.prototype.publish">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publish
        <span class="apidocSignatureSpan">(message, payload, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publish = function (message, payload, callback) {

    payload                             = payload || {};

    if (!MINIFIED){
        this.log('publish', 'Publishing message:', message);
    }

    if (typeof message === 'string') {
        message                         = [message];
    }

    for (var i=0;i&lt;message.length;i++) {
        this.pubsub.publish(message[i],payload);
    }

    if (typeof callback === 'function') {
        callback();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.setResponse('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.start()] Starting Turbine\r\n[CartExample.<span class="apidocCodeKeywordSpan">publish</span>()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.stop();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.getVar('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.publishAndWait" id="apidoc.element.turbine.js.Turbine.prototype.publishAndWait">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publishAndWait
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publishAndWait = function (query, response) {

    var self                            = this;
    var message                         = null;
    var using                           = {};

    if (this.utils.isObjLiteral(response.publish)) {

        message                         = response.publish.message;
        using                           = this.getUsingObject(response.publish.using);

    } else {

        message                         = response.publish;
    }

    using.counter                       = (typeof response.repeat !== 'undefined') ? response.repeat.counter : 0;

    if (!MINIFIED){
        this.log('publishAndWait', 'Publishing message and waiting for response', {

            message                     : message,
            using                       : using,
            response                    : response
        });
    }

<span class="apidocCodeCommentSpan">    /* After message is published, callback must be called to process the rest of the response */
</span>    var callback = function() {

        response.isPublishCallback      = true;

        self.processResponse(query,response);
    };

    this.publish(message,using,callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                    this.publishNow(query,response);
                }

                /* If we have "publish" with "waitFor", then publish the message and wait for a response
                 * before continuing. */
                if (response.publish &amp;&amp; response.waitFor &amp;&amp; !response.isPublishCallback) {

                    this.<span class="apidocCodeKeywordSpan">publishAndWait</span>(query,response);

                } else {

                    if (response.repeat) {

/* Clean up isAfterDelay flag */
if (response.isAfterDelay) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.publishNow" id="apidoc.element.turbine.js.Turbine.prototype.publishNow">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>publishNow
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publishNow = function (query, response) {

    var message                         = null;
    var using                           = {};

    if (this.utils.isObjLiteral(response.publish)) {

        message                         = response.publish.message;
        using                           = this.getUsingObject(response.publish.using);

    } else {

        message                         = response.publish;
    }

    this.publish(message,using);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                if (response.report &amp;&amp; !response.isPublishCallback) {
this.reportIssueFromWorkflow(query,response);
                }

                /* If we have "publish" with no "waitFor", then just publish the message and move on */
                if (response.publish &amp;&amp; !response.waitFor &amp;&amp; !response.isPublishCallback) {

this.<span class="apidocCodeKeywordSpan">publishNow</span>(query,response);
                }

                /* If we have "publish" with "waitFor", then publish the message and wait for a response
                 * before continuing. */
                if (response.publish &amp;&amp; response.waitFor &amp;&amp; !response.isPublishCallback) {

this.publishAndWait(query,response);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.queue" id="apidoc.element.turbine.js.Turbine.prototype.queue">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>queue
        <span class="apidocSignatureSpan">(waitFor, nextQuery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (waitFor, nextQuery) {

    if (this.waitingFor) {
        this.remove(this.waitingFor);
    }

    var result                          = this.parseWaitFor(waitFor,nextQuery,true);

    this.waitingFor                     = result.waitingFor;
    this.nextQueryObj                   = result.nextQueryObj;
    this.nextQuery                      = nextQuery;

    if (this.waitingFor.length &gt; 0){
        this.listen(this.waitingFor,this.handleIncomingMessage.bind(this));
    }

    if (!MINIFIED){

        if (this.waitingFor.length &gt; 0){
            this.log('queue', 'Waiting for', this.waitingFor);
        }

        this.log('queue', 'Queuing next query', this.nextQueryObj);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('start', 'Starting Turbine');
    }

    this.started                        = true;

    this.<span class="apidocCodeKeywordSpan">queue</span>(null,this.getStartingQuery());
    this.next();
},

/**
 * Stops Turbine
 */
stop : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.remove" id="apidoc.element.turbine.js.Turbine.prototype.remove">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>remove
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (message) {

    if (!MINIFIED){
        this.log('remove', 'Removing listener for:', message, 'TRACE');
    }

    if (typeof message === 'string') {
        message                         = [message];
    }

    for (var i=0;i&lt;message.length;i++) {
         this.pubsub.remove(message[i]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (typeof message === 'string') {
        message                         = [message];
    }

    for (var i=0;i&lt;message.length;i++) {
         this.pubsub.<span class="apidocCodeKeywordSpan">remove</span>(message[i]);
    }
},

/**
 * Starts Turbine by executing the first queued query
 */
start : function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.repeat" id="apidoc.element.turbine.js.Turbine.prototype.repeat">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>repeat
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repeat = function (query, response) {

    response.repeat.counter            += 1;

    if (!MINIFIED){
        this.log('repeat', 'Repeating ' + query + ' (' + response.repeat.counter + ' of ' + response.repeat.limit + ' max)');
    }

<span class="apidocCodeCommentSpan">    /* If the limit is null, repeat query indefinitely */
</span>    if (response.repeat.limit === null) {

        this.queue(response.waitFor,query);
    }
    /* If the limit has been reached, use fallback response */
    else if (response.repeat.counter &gt;= response.repeat.limit) {

        if (!MINIFIED){
            this.log('repeat', 'Maximum repeat limit for ' + query + ' reached or exceeded (' + response.repeat.counter + ' of ' +
response.repeat.limit + ' max)');
        }

        this.processResponse(query,response.repeat);
    }
    /* If limit hasn't been reached, queue or execute same query again */
    else {

        if (response.waitFor) {

            /* When waitFor is an array, it is passed by reference. Because the global listeners are added
             * every time we call queue(), and because waitFor is a reference, the global listeners end up
             * being pushed onto the array over and over. Slicing them off here means they can be added again
             * without stacking up. */
            if (this.utils.isArray(response.waitFor) &amp;&amp; response.repeat.counter &gt; 1) {
                response.waitFor        = response.waitFor.slice(0,response.waitFor.length - this.numAlwaysWaitFor);
            }

            this.queue(response.waitFor,query);

        } else {

            this.exec(query);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        delete response.isAfterDelay;
    } catch (e) {
        response.isAfterDelay       = undefined;
    }
}

/* "repeat" repeats query */
this.<span class="apidocCodeKeywordSpan">repeat</span>(query,response);

                    }
                    /* "waitFor" tells us to wait for a message (or messages) before executing "then" query */
                    else if (response.waitFor) {

this.queue(response.waitFor,response.then);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.replace" id="apidoc.element.turbine.js.Turbine.prototype.replace">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replace
        <span class="apidocSignatureSpan">(target, source, prepend, recursive, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (target, source, prepend, recursive, type) {

    for (var item in target) {

        if (target.hasOwnProperty(item)) {

            var thisItem                = target[item];

<span class="apidocCodeCommentSpan">            /* Replace target with values defined in source */
</span>            if (typeof thisItem === 'string' &amp;&amp; thisItem.indexOf(prepend) === 0) {

                thisItem                = thisItem.substr(1);

                if (source[thisItem]) {

                    if (!MINIFIED){
                        this.log('replace', 'Replacing ' + prepend + thisItem + ' ' + type + ' with', source[thisItem], 'TRACE');
                    }

                    target[item]        = source[thisItem];
                }

            } else if (recursive &amp;&amp; typeof thisItem === 'object') {

                this.replace(thisItem,source,prepend,recursive,type);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /* Replace variables with values defined in source */
        if (typeof thisTarget === 'string' &amp;&amp; thisTarget.indexOf(thisVar) &gt; -1) {

            if (!MINIFIED){
                this.log('replace', 'Replacing ' + thisVar + ' variable with "' + replaceWith
 + '"', null , 'TRACE');
            }

            target[item]    = thisTarget.<span class="apidocCodeKeywordSpan">replace</span>(new RegExp('\\'+thisVar,&amp;#
x27;g'),replaceWith);

        } else if (this.utils.isObjLiteral(thisTarget)) {

            this.replaceVariables(thisTarget);
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.replaceMixins" id="apidoc.element.turbine.js.Turbine.prototype.replaceMixins">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceMixins
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceMixins = function (target) {
    this.replace(target,this.mixins,'+',true,'mixin');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('importWorkflow', 'Importing workflow', null, 'DEBUG');
    }

    this.workflow                       = initObj.workflow || {};

    this.<span class="apidocCodeKeywordSpan">replaceMixins</span>(this.workflow);

    if (this.utils.isObjLiteral(initObj.workflow)) {
        this.importQueries(initObj.workflow);
    }

} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.replaceShortcuts" id="apidoc.element.turbine.js.Turbine.prototype.replaceShortcuts">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceShortcuts
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceShortcuts = function (response) {
    this.replace(response,this.shortcuts,'@',true,'shortcut');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            if (!MINIFIED){
this.log('importAlways', 'Importing always', this.always, 'DEBUG');
            }

            if (typeof this.always.waitFor !== 'undefined'){

this.<span class="apidocCodeKeywordSpan">replaceShortcuts</span>(this.always.waitFor);
this.replaceVariables(this.always.waitFor);

var result                      = this.parseWaitFor(this.always.waitFor);

this.alwaysWaitFor              = result.nextQueryObj;
this.numAlwaysWaitFor           = result.waitingFor.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.replaceVariables" id="apidoc.element.turbine.js.Turbine.prototype.replaceVariables">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>replaceVariables
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceVariables = function (target) {

    var thisTarget, thisVar, replaceWith;

    for (var variable in this.variables){

        if (this.variables.hasOwnProperty(variable)){

            for (var item in target) {

                if (target.hasOwnProperty(item)) {

                    thisTarget          = target[item];
                    thisVar             = '$'+variable;
                    replaceWith         = this.variables[variable];

<span class="apidocCodeCommentSpan">                    /* Replace variables with values defined in source */
</span>                    if (typeof thisTarget === 'string' &amp;&amp; thisTarget.indexOf(thisVar) &gt; -1) {

                        if (!MINIFIED){
                            this.log('replace', 'Replacing ' + thisVar + ' variable with "' + replaceWith + '"', null , 'TRACE');
                        }

                        target[item]    = thisTarget.replace(new RegExp('\\'+thisVar,'g'),replaceWith);

                    } else if (this.utils.isObjLiteral(thisTarget)) {

                        this.replaceVariables(thisTarget);
                    }
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (!MINIFIED){
this.log('importAlways', 'Importing always', this.always, 'DEBUG');
            }

            if (typeof this.always.waitFor !== 'undefined'){

this.replaceShortcuts(this.always.waitFor);
this.<span class="apidocCodeKeywordSpan">replaceVariables</span>(this.always.waitFor);

var result                      = this.parseWaitFor(this.always.waitFor);

this.alwaysWaitFor              = result.nextQueryObj;
this.numAlwaysWaitFor           = result.waitingFor.length;

if (!MINIFIED){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.report" id="apidoc.element.turbine.js.Turbine.prototype.report">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>report
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (obj) {

    if (!MINIFIED){

        obj                             = (this.utils.isObjLiteral(obj)) ? obj : {};
        var handle                      = obj.handle || 'WORKFLOW_ISSUE_REPORTED';
        var desc                        = obj.description || '';

        this.log('report', handle + ': ' + desc, obj, 'ERROR');
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    var Turbine = function Turbine(initObj) {

if (typeof initObj !== 'object' || initObj === null){

    var errorMsg                        = 'Turbine constructor must be passed an initialization object';

    this.<span class="apidocCodeKeywordSpan">report</span>({
        handle                          : 'INIT_OBJ_NOT_DEFINED',
        desc                            : errorMsg
    });

    throw new Error(errorMsg);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.reportIssueFromWorkflow" id="apidoc.element.turbine.js.Turbine.prototype.reportIssueFromWorkflow">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>reportIssueFromWorkflow
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportIssueFromWorkflow = function (query, response){

    var responseName                    = this.responses[query];
    response.report                     = (this.utils.isObjLiteral(response.report)) ? response.report : {};

<span class="apidocCodeCommentSpan">    /* Add workflow info to report */
</span>    response.report.workflow = {
        name                            : this.name,
        query                           : query,
        response                        : responseName,
        responseObj                     : this.workflow[query][responseName],
        timestamp                       : new Date().getTime()
    };

    this.report(response.report);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.startDelayTimeout(query,response);

            } else {

/* "report" tells us to report an issue. We only want to report it once, so
 * we ignore it if we're processing the response as part of a publish callback */
if (response.report &amp;&amp; !response.isPublishCallback) {
    this.<span class="apidocCodeKeywordSpan">reportIssueFromWorkflow</span>(query,response);
}

/* If we have "publish" with no "waitFor", then just publish the message and move on */
if (response.publish &amp;&amp; !response.waitFor &amp;&amp; !response.isPublishCallback) {

    this.publishNow(query,response);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.resetResponse" id="apidoc.element.turbine.js.Turbine.prototype.resetResponse">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>resetResponse
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetResponse = function (query) {

<span class="apidocCodeCommentSpan">    /* If the query is dirty, just clear the dirty flag. Don't reset the response. */
</span>    if (this.isDirtyQuery(query)){

        this.dirtyQueries[query]        = null;

    }
    /* If the query isn't dirty, reset the response */
    else {

        var didReset                    = false;

        if (typeof this.resets[query] === 'function'){

            this.responses[query]       = this.resets[query]();
            didReset                    = true;

        } else if (typeof this.resets[query] !== 'undefined'){

            this.responses[query]       = this.resets[query];
            didReset                    = true;
        }

        if (!MINIFIED){

            if (didReset){
                this.log('resetResponse', 'Reset ' + query + ' response to', this.responses[query] || 'false', 'DEBUG');
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        if (this.workflow[query].hasOwnProperty(response) &amp;&amp; this.workflow[query][response].repeat) {

            this.workflow[query][response].repeat.counter = 0;
        }
    }

    this.<span class="apidocCodeKeywordSpan">resetResponse</span>(query);
},

/**
 * Checks whether there's a function to get a response to the query
 *
 * @param query The query for which to get a function
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.rewind" id="apidoc.element.turbine.js.Turbine.prototype.rewind">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>rewind
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewind = function (from, to) {

    this.clearTimers();

    var clearing                        = false;
    var numQueries                      = this.queryOrder.length;
    from                                = from || this.queryOrder[numQueries-1];
    to                                  = to || this.queryOrder[0];

    if (!MINIFIED){
        this.log('rewind', 'Rewinding from ' + from + ' to ' + to, null, 'DEBUG');
    }

    for (var i=numQueries;i&gt;=0;i--) {

        var query                       = this.queryOrder[i];

        if (query === from) {
            clearing                    = true;
        }

        if (clearing) {
            this.clear(query);
        }

        if (query === to) {
            break;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!MINIFIED){
        this.log('stop', 'Stopping Turbine');
    }

    this.started                        = false;

    this.<span class="apidocCodeKeywordSpan">rewind</span>();
},

/**
 * Kills Turbine (It is stopped and can't be restarted)
 */
kill : function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.setResponse" id="apidoc.element.turbine.js.Turbine.prototype.setResponse">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>setResponse
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setResponse = function (query, response) {

    if (!MINIFIED){
        this.log('setResponse', 'Setting "' + query + '" response to ' + response);
    }

    this.responses[query]               = response;
    this.dirtyQueries[query]            = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.<span class="apidocCodeKeywordSpan">setResponse</span>('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.start()] Starting Turbine\r\n[CartExample.publish()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.stop();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.getVar('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.setResponseTimeout" id="apidoc.element.turbine.js.Turbine.prototype.setResponseTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>setResponseTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setResponseTimeout = function (query, response) {

    if (!this.timers.queries[query]) {
        this.timers.queries[query]      = [];
    }

    var self                            = this;

    var timeout = setTimeout(function() {

        self.onResponseTimeout(query,response);

    },response.timeout.after);

    this.timers.queries[query].push(timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} catch (e) {
    response.isPublishCallback  = undefined;
}
                    }

                    /* If this response has a timeout, set the timer */
                    if (response.timeout) {
this.<span class="apidocCodeKeywordSpan">setResponseTimeout</span>(query,response);
                    }

                    /* Clean up isAfterDelay flag */
                    if (response.isAfterDelay) {

try {
    delete response.isAfterDelay;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.start" id="apidoc.element.turbine.js.Turbine.prototype.start">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {

    if (this.isKilled()){

        if (!MINIFIED){
            this.log('start', 'Cannot start Turbine. It has already been killed.', null, 'ERROR');
        }

        return null;
    }

    if (!MINIFIED){
        this.log('start', 'Starting Turbine');
    }

    this.started                        = true;

    this.queue(null,this.getStartingQuery());
    this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.setResponse('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.<span class="apidocCodeKeywordSpan">start</span>()] Starting Turbine\r\n[CartExample.publish()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.stop();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.getVar('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.startDelayTimeout" id="apidoc.element.turbine.js.Turbine.prototype.startDelayTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>startDelayTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startDelayTimeout = function (query, response) {

    if (!MINIFIED){
        this.log('startDelayTimeout',query + ' delay started. Delayed for ' + response.delay.for + ' ms', response);
    }

    var self                            = this;

    this.timers.delay = setTimeout(function() {

        self.onDelayTimeout(query,response);

    },response.delay.for);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            if (!preventGlobalTimeout) {
this.startGlobalTimeout(query,response);
            }

            if (response.delay &amp;&amp; !response.isAfterDelay) {

this.<span class="apidocCodeKeywordSpan">startDelayTimeout</span>(query,response);

            } else {

/* "report" tells us to report an issue. We only want to report it once, so
 * we ignore it if we're processing the response as part of a publish callback */
if (response.report &amp;&amp; !response.isPublishCallback) {
    this.reportIssueFromWorkflow(query,response);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.startGlobalTimeout" id="apidoc.element.turbine.js.Turbine.prototype.startGlobalTimeout">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>startGlobalTimeout
        <span class="apidocSignatureSpan">(query, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startGlobalTimeout = function (query, response) {

    if (!this.isGlobalTimeoutAllowed()) {
        return false;
    }

    this.clearGlobalTimer();

    if (!MINIFIED){
        this.log('startGlobalTimeout', 'Starting global timer', this.always.timeout, 'TRACE');
    }

    var timeout                         = this.getGlobalTimeout();
    var self                            = this;

    this.timers.global = setTimeout(function() {

        self.onGlobalTimeout(query,response);

    },timeout);

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (!MINIFIED){
    this.log('processResponse', 'Processing response to '+query+' query', response, 'TRACE'
;);
}

if (!preventGlobalTimeout) {
    this.<span class="apidocCodeKeywordSpan">startGlobalTimeout</span>(query,response);
}

if (response.delay &amp;&amp; !response.isAfterDelay) {

    this.startDelayTimeout(query,response);

} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.stop" id="apidoc.element.turbine.js.Turbine.prototype.stop">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function () {

    if (!MINIFIED){
        this.log('stop', 'Stopping Turbine');
    }

    this.started                        = false;

    this.rewind();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  {
    "name": "wmbenedetto",
    "email": "warren@transfusionmedia.com"
  }
],
"name": "turbine.js",
"optionalDependencies": {},
"readme": "# Turbine\r\n\r\nTurbine is a JavaScript workflow engine. It vastly simplifies the development, deployment
, and testing of complex web applications through the use of declarative workflows that express your app's program logic in
 a form that is simple to read and to understand.\r\n\r\n## Why Turbine?\r\n\r\nTurbine is the ideal solution for apps (or parts of apps) with multi-step processes involving many possible branches, sub-flows, or permutations. Examples include:\r\n\r\n* Signup forms\r\n* Login forms\r\n* Interactive tours\r\n* Shopping carts\r\n* Checkout flows\r\n* Asset creation (i.e. upload photo -&gt; add filter -&gt; add caption -&gt; tag friends -&gt; share)\r\n* etc.\r\n\r\nThe programming of these types of apps usually involves a tangled nightmare of conditionals, switches, callbacks, promises, and other strands of spaghetti code. \r\n\r\nThis tightly coupled code makes it almost impossible to A/B/n test different flows or variations -- any attempt to do so usually makes the problem even worse. It is also very difficult to follow the program logic to trace all the possible flows through the code.\r\n\r\nThe end result is code which is dense, brittle, untestable, obtuse, and just plain gross.\r\n\r\nTurbine was written to solve these problems by taking the program logic of complex apps and abstracting it out into a simple document (the *workflow*) which is easy to read and understand. \r\n\r\n## Quick install\r\n\r\nTurbine is available via a number of popular package managers:\r\n\r\n### NPM\r\n\r\n```\r\nnpm install turbine.js\r\n```\r\n\r\n### JamJS\r\n```\r\njam install turbine.js\r\n```\r\n\r\n### Bower\r\n```\r\nbower install turbine.js\r\n```\r\n\r\nOr you can download the latest tag from https://github.com/wmbenedetto/turbine.js/tags\r\n\r\n## Key concepts\r\n\r\nIn order to use Turbine, it's important to first define some key concepts. Once we have a common vocabulary and general conceptual understanding established, we can then begin talking about how you can use Turbine to power your app.\r\n\r\n### Workflow\r\n\r\nThe workflow is the jet fuel that powers Turbine. It's an expressive, declarative syntax for defining the program flow of your application. It allows you to define all the logical branching of your app in a single document, in a format that is both human- and machine-readable. \r\n\r\nTurbine workflows are declarative -- they are only concerned with *what* your app does, not *how* it does it. Although workflows are written in JavaScript, they should not contain any functional logic. They should be serializable to JSON -- and deserializable from JSON --  without any ill effects.\r\n\r\nA workflow is essentially a series of questions (queries) and answers (responses). It's almost like a conversation between Turbine and your app.\r\n\r\n&gt;**Turbine:** Is the user signed up?\r\n&gt;\r\n&gt;**Your app:** Nope.\r\n&gt;\r\n&gt;**Turbine:** Okay. Ask him to sign up. I'll wait.\r\n&gt;\r\n&gt;*Your app displays a signup form. The user fills it in and clicks Submit.*\r\n&gt;\r\n&gt;**Your app:** Alrighty, he signed up.\r\n&gt;\r\n&gt;**Turbine:** Great. Is he over 18?\r\n&gt;\r\n&gt;**Your app:** No, he's only 13.\r\n&gt;\r\n&gt;**Turbine:** Damn. Ask him for his parent's email, then let me know.\r\n&gt;\r\n&gt;*Your app asks for the parent's email. The user submits it.*\r\n&gt;\r\n&gt;**Your app:** I got the parent's email.\r\n&gt;\r\n&gt;**Turbine:** Is is valid?\r\n&gt;\r\n&gt;**Your app:** Yep, looks good.\r\n&gt;\r\n&gt;**Turbine:** Great! Let him in. We're done!\r\n\r\nNow let's look at the same \"conversation\" expressed as a workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n    \r\n    // Turbine: Is the user signed up?\r\n    isUserSignedUp : {\r\n        // Your app: Nope.\r\n        no : {\r\n            // Turbine: Okay. Ask him to sign up. I'll wait.\r\n            publish : {\r\n                message : 'Signup.stepOne.show'\r\n            },\r\n            waitFor : 'Signup.stepOne.submitted',\r\n            \r\n            // Your app is listening for a Signup.stepOne.show message. It knows to handle\r\n            // that by displaying a signup form. The user fills it in and clicks Submit.\r\n            // This publishes a Signup.stepOne.submitted message. Which is equivalent to:\r\n            //\r\n            // Your app: Alrighty, he signed up.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isOver18'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        },\r\n    },\r\n    \r\n    // Turbine: Great. Is he over 18?\r\n    isOver18 : {\r\n        // Your app: No, he's only 13.\r\n        no : {\r\n            // Turbine: Damn. Ask him for his parent's email, then let me know.\r\n            publish : {\r\n                message : 'Signup.parentEmail.show'\r\n            },\r\n            waitFor : 'Signup.parentEmail.submitted',\r\n            \r\n            // Your app is listening for a Signup.parentEmail.show message. It knows to handle\r\n            // that by displaying a form that asks the user for his parent's email address.\r\n            // The user enters the email and clicks Submit. This publishes a Signup.parentEmail.submitted message. \r\n            // Which is equivalent to:\r\n            //\r\n            // Your app: I got the parent's email.\r\n            // \r\n            // Turbine moves to its next \"question\"\r\n            then : 'isParentEmailValid'\r\n        },\r\n        \r\n        yes : {\r\n            then : 'stop.'\r\n        }\r\n    },\r\n    \r\n    // Turbine: Is is valid?\r\n    isParentEmailValid : {\r\n        // Your app: Yep, looks good.\r\n        yes : {\r\n            // Turbine: Great! Let him in. We're done!\r\n            publish : {\r\n                message : 'Signup.form.complete'\r\n            },\r\n            then : 'stop.'\r\n        }, \r\n        \r\n        no : {\r\n            publish : {\r\n                message : 'Signup.error.show.INVALID_EMAIL_ADDRESS'\r\n            },\r\n            then : 'isOver18'\r\n        }\r\n    }\r\n \r\n};\r\n```\r\n\r\n---\r\n\r\n### Queries\r\n\r\nQueries are the questions that Turbine asks your app. Therefore, a query is a string typically written as a question, such as:\r\n\r\n* isUserLoggedIn\r\n* canOpenGoldDoor\r\n* whichErrorCode\r\n* howManyStars\r\n\r\n#### Query phrasing\r\n\r\nGenerally, queries should be phrased so that the affirmative answer (if there is one) is the answer you want/expect. \r\n\r\nFor example, say you want to confirm that a plugin is the latest version. There are two ways you could write the same query: `isPluginOutdated` or `isPluginUpToDate`. \r\n\r\nSince you want and expect the plugin to be up-to-date, the preferred phrasing would be `isPluginUpToDate`. \r\n\r\nPhrasing your queries this way means that the \"happy path\" through your app is a series of yesses. Is the plugin up to date? Yes! Is the game loaded? Yes! Is the user logged in? Yes! And so on.\r\n\r\n#### Query functions\r\n\r\nWhen you instantiate an instance of Turbine, you can (but don't have to) define functions from your app that Turbine can use to execute the query.\r\n\r\nFor example, if your app only lets magicians open gold doors, you might define a query function like:\r\n\r\n```javascript\r\nvar initObj = {\r\n    queries : {\r\n        canOpenGoldDoor : user.isMagician.bind(user)\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine gets to the `canOpenGoldDoor` query in your workflow, it will execute `user.isMagician()`, which will return `true` or `false`. This is the \"response.\"\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses are the answers your app returns for queries.\r\n\r\nResponses are often simple booleans: true or false get converted to \"yes\" or \"no\" by Turbine. However, the response really can be any arbitrary string or number. Responses for the query examples above might look like:\r\n\r\n* isUserLoggedIn\r\n    * yes\r\n    * no\r\n* canOpenGoldDoor\r\n    * yes\r\n    * no\r\n* whichErrorCode\r\n    * INVALID_EMAIL\r\n    * INVALID_CREDIT_CARD\r\n    * MUST_CHECK_TERMS_BOX\r\n* howManyStars\r\n    * 1\r\n    * 2\r\n    * 3\r\n    * 4\r\n    * 5\r\n\r\nResponses can be defined in a couple of ways.    \r\n\r\n#### Via query functions\r\n\r\nThe most obvious way to get a response is as a value returned by the query function. When the `canOpenGoldDoor` query executes the `user.isMagician()` function, whatever that function returns gets set as the response to `canOpenGoldDoor`: true, which gets converted to \"yes\".\r\n\r\n#### Via `setResponse()`\r\n\r\nThe second way a response can be defined is via Turbine's `setResponse()` method. This isn't really the preferred way of doing things, since it requires more tightly coupling your app with Turbine and your workflow. However, it's an option you can use if you need it.\r\n\r\nFor example, say you have some form validation logic. You could do something like:\r\n\r\n```javascript\r\nif (user.email.indexOf('@') &lt; 0){\r\n    turbine.setResponse('whichErrorCode','INVALID_EMAIL');\r\n}\r\n```\r\nWhen Turbine reaches the `whichErrorCode` query, it will first check if a query function has been defined. It hasn't been, so Turbine then checks to see which response was set via `setResponse()`.\r\n\r\n#### Via initialization object\r\n\r\nWhen Turbine is instantiated, you can define default responses in the init object passed to the constructor. Since Turbine defaults all responses to false, you only need to define defaults for non-false values.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        isLoggedIn : true,\r\n        howManyStars : 3\r\n    }  \r\n};\r\n```\r\n\r\nWhen Turbine executes a query and 1.) no query function has been defined, and 2.) no reponse has been set via `setResponse()`, then it will use the response from the init object (or false if none is defined).\r\n\r\n---\r\n\r\n### Resets\r\n\r\nWorkflows don't always move inexorably forward in a straight line. Sometimes they need to backtrack, repeat, start over, etc. When this happens, you may need to reset some of the responses you previously set.\r\n\r\nJust like query functions and default responses, resets are defined in the init object passed to the Turbine constructor. A reset can be either a function reference, or a simple value.\r\n\r\nFor example, consider a login form that limits a user to 3 login attempts before locking the login form. By default, the user can attempt to login, so the default response for `canAttemptLogin` is true. \r\n\r\nIn addition, a reset function is defined for the `canAttemptLogin` query. This will be executed whenever Turbine moves backwards through the workflow past `canAttemptLogin`.\r\n\r\n```javascript\r\nvar initObj = {\r\n    responses : {\r\n        canAttemptLogin : true\r\n    },\r\n    resets : {\r\n        canAttemptLogin : user.hasLoginAttemptsRemaining.bind(user)\r\n    }\r\n};\r\n```\r\n\r\nThe login workflow is very simple. We check if the user can attempt a login. If he can, we publish a message telling the app to show the form, and we wait until the form is submitted. Then we check if the login is valid.\r\n\r\nIf the login is not valid, then we publish a message telling the app there has been an error, then we wait for a message telling us the user wants to retry. When we get that message, we **rewind** the workflow and replay the `canAttemptLogin` query.\r\n\r\nHere's that workflow:\r\n\r\n```javascript\r\nvar workflow = {\r\n            \r\n    canAttemptLogin : {\r\n        yes : {\r\n            publish : {\r\n                message : 'LoginForm.show'\r\n            },\r\n            waitFor : 'LoginForm.submit',\r\n            then : 'isLoginValid'\r\n        },\r\n        no : {\r\n            // publish message to disable login form\r\n        }\r\n    },\r\n    \r\n    isLoginValid : {\r\n        yes : {\r\n            // publish message to let user into site\r\n        },\r\n        no : {\r\n            publish : {\r\n                message : 'LoginForm.error'\r\n            },\r\n            waitFor : 'LoginForm.retry',\r\n            then : 'canAttemptLogin'\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe key here is the rewind: whenever we go backwards in the workflow, Turbine checks to see if a reset function (or value) has been defined for each query we have already passed. \r\n\r\nIn this example, we defined a reset function for `canAttemptLogin` in our init object. Therefore, each time we rewind from `isLoginValid` back to `canAttemptLogin`, Turbine calls the `user.hasLoginAttemptsRemaining()` function. \r\n\r\nThe first time through, this will return true. Second time, true. Third time, true. \r\n\r\nBut when we rewind the fourth time, it will return *false.* So when the `canAttemptLogin` query is executed for the fourth time, it will follow the \"no\" response instead, locking the form against further attempts.\r\n\r\n---\r\n\r\n### Events/Messages\r\n\r\nTurbine is an event-driven workflow engine. In the Turbine world, events are called **messages**. Turbine both **publishes** messages and **waits for** messages.\r\n\r\nWhen Turbine publishes a message, the expectation is that your app is listening for that message. When your app gets the message, it goes off and does whatever it needs to do.\r\n\r\nWhen your app is finished doing its thing, it publishes its own message saying it's done.\r\n\r\nIf Turbine is waiting for that message, it will pick up where it left off, executing the next query in the workflow.\r\n\r\nBy using `publish` and `waitFor` together like this, Turbine is basically telling your app, \"Hey, go do some stuff, and let me know when you're done. Then I'll keep going.\"\r\n\r\nOf course, there's no requirement that you wait for a return message after you publish. You can just publish and move on through the workflow. Likewise, you can wait for a message without having published one previously.\r\n\r\n```javascript\r\nvar workflow = {\r\n        \r\n    isAppStarted : {\r\n        \r\n        // You can wait for a message without having published one previously\r\n        yes : {\r\n            waitFor : 'App.stepOne.complete',\r\n            then : 'isAfterMidnight'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n\r\n    isAfterMidnight : {\r\n        \r\n        // You can publish a message without waiting for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.theme.update.DARK_BACKGROUND'\r\n            },\r\n            then : 'isStepOneComplete'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isStepOneComplete : {\r\n        \r\n        // You can publish a message then wait for a return message\r\n        yes : {\r\n            publish : {\r\n                message : 'App.stepTwo.show'\r\n            },\r\n            waitFor : 'App.stepTwo.complete'\r\n            then : 'stop.'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n.\r\n\r\n## Initializing Turbine\r\n\r\nEach instance of Turbine is initialized by calling the Turbine constructor and passing it a single `initObj` object literal.\r\n\r\nThe documentation below has more detail about what each property means, but here is the basic structure. Note that only `workflow` is required; the rest are optional.\r\n\r\n```javascript\r\n// Create initialization object\r\nvar initObj = {\r\n    \r\n    // REQUIRED\r\n    workflow    : {},           \r\n    \r\n    // OPTIONAL\r\n    name        : '',           \r\n    logLevel    : '',           \r\n    queries     : {},          \r\n    responses   : {},           \r\n    resets      : {},\r\n    shortcuts   : {},\r\n    variables   : {},\r\n    mixins      : {},\r\n    always      : {},\r\n    init        : function(){}, \r\n    log         : function(){}, \r\n    publish     : function(){}, \r\n    listen      : function(){}, \r\n    remove      : function(){}, \r\n    report      : function(){} \r\n};\r\n\r\n// Instantiate new Turbine instance using initObj\r\nvar turbine = new Turbine(initObj);\r\n```\r\n\r\nNow let's look at what each of these properties means.\r\n\r\n---\r\n\r\n### workflow\r\n\r\n*[OBJECT] Defines the control flow of your application*\r\n\r\nThe workflow is the jet fuel that powers Turbine. It tells your app what to do, and where to go next after doing it.\r\n\r\nSince workflows are a whole topic unto themselves, see the [Elements of a workflow](#elements-of-a-workflow) section for more details.\r\n\r\n---\r\n\r\n### name \r\n\r\n*[STRING] Gives your Turbine instance a unique name for logging purposes.*\r\n\r\nThis can be useful when you have multiple Turbine instances running simultaneously (or sequentially) and you want to disambiguate the log messages from each instance. \r\n\r\nFor example, if `initObj.name` is set to \"CartExample\", then the console logs will look like:\r\n\r\n```\r\n[CartExample.start()] Starting Turbine\r\n[CartExample.publish()] Publishing message: Turbine|workflow|started\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n```\r\n\r\nIf you were to spin up another Turbine instance with an `initObj.name` of \"SignupExample\", you'd be able to tell the difference from CartExample:\r\n\r\n```\r\n[CartExample.publish()] Publishing message: Turbine|workflow|waiting \r\n[SingupExample.start()] Starting Turbine\r\n[SingupExample.publish()] Publishing message: Turbine|workflow|started\r\n```\r\n\r\nIf no `name` property is set, then the default value will be \"Turbine\", i.e. `[Turbine.start()] Starting Turbine`\r\n\r\n---\r\n\r\n### logLevel\r\n\r\n*[STRING] Determines the verbosity of the logs being output to the console.*\r\n\r\n**Logging is only available in the non-minified version of Turbine.js.** In the minified version, all logging functionality is stripped out to reduce file size.\r\n\r\nValid values for `initObj.logLevel`, in order of increasing verbosity, are:\r\n\r\n* `OFF`\r\n* `ERROR`\r\n* `WARN`\r\n* `INFO`\r\n* `DEBUG`\r\n* `TRACE`\r\n\r\nThe default value is `ERROR`.\r\n\r\n---\r\n\r\n### queries\r\n\r\n*[OBJECT] Functions used to resolve queries and return responses.*\r\n\r\nThe `initObj.queries` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is a reference to a function that will return the result of the query (a.k.a. the response).\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    queries : {\r\n        isFoo               : someGlobalFunction,\r\n        isLoggedIn          : app.isLoggedIn.bind(app),\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        getsSpecialOffer    : cart.getsSpecialOffer.bind(cart),\r\n        whichItemMissing    : cart.getMissingItem.bind(cart)\r\n    }\r\n}\r\n```\r\n\r\nAs Turbine steps through each query in your workflow, it looks for a corresponding function defined in `initObj.queries`. If found, the query function is executed. The return value tells Turbine which response to process.\r\n\r\nDefining query functions here promotes decoupling of your workflow from the rest of your app. The functions don't need to know anything about the workflow or how all the pieces of the app fit together -- they just need to be able to return a valid response, and Turbine (along with your workflow) does the rest.\r\n\r\n#### Function references\r\n\r\nIt's important to note that the functions in `initObj.queries` are just references -- they are not actually called here. You can see this most clearly with the `isFoo : someGlobalFunction` example. Notice that `someGlobalFunction` does not have parentheses after it. That's what makes it a reference instead of an executed function.\r\n\r\n#### Binding functions\r\n\r\nSo what's this `bind` stuff at the end of the other functions? In a nutshell, `bind` tells the function what the scope of `this` should be when it's used inside the function. \r\n\r\n`bind` is actually a [feature](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind) of the Function prototype in ECMAScript 5 (JavaScript 1.8.5), and is supported by all modern browsers. In other words, everything but IE8. \r\n\r\nNever fear though ... Turbine includes an implementation of `bind`, so you can use it even in browsers that don't technically support it.\r\n\r\n**To ensure that your function is always being called with `this` scoped correctly, you should always use `bind` when defining your query functions.**\r\n\r\n---\r\n\r\n### responses\r\n\r\n*[OBJECT] Default responses to workflow queries.*\r\n\r\nThe `responses` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is the default response for that query.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    responses : {\r\n        isCartEmpty         : true,\r\n        whichItemMissing    : 'playstation'\r\n    }\r\n}\r\n```\r\n\r\nResponses are `false` by default, so `initObj.responses` is your chance to define a non-false default response for a query.\r\n\r\nWhen Turbine is instantiated, it imports these default responses. If no query function is defined in `initObj.queries`, and the response isn't explicitly set in your app via the `setResponse()` method, then the value from `initObj.responses` is used.\r\n\r\n---\r\n\r\n### resets\r\n\r\n*[OBJECT] Functions or values used to reset query responses when rewinding a workflow*\r\n\r\nThe `resets` object is a collection of key:value pairs. Each key is the name of a query that appears in your workflow; each corresponding value is either a function or a value to use when rewinding the workflow.\r\n\r\nFor example:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    resets : {\r\n        isCartEmpty         : cart.isCartEmpty.bind(cart),\r\n        isCheckoutStarted   : true\r\n    }\r\n}\r\n```\r\n\r\nSometimes Turbine executes a query response that requires it to go backwards in the workflow, to an earlier query. For example, a user may get several steps through a checkout process, then decides to backtrack a few steps to remove a product from the cart.\r\n\r\nWhen this happens, it may be necessary to reset some of the responses that are being rewound. For example, if a user is on Step 4 of the checkout, and wants to go back to Step 2, you may need to reset the value of a `isStepThreeComplete` query to false.\r\n\r\nTo do this you could either set `initObj.resets.isStepThreeComplete = false`, or your could set it to a function to be  called to determine the reset value, i.e. `initObj.resets.isStepThreeComplete = app.isStepThreeComplete.bind(app)`.\r\n\r\nIf no reset for a query is defined in `initObj.resets`, then the response is not reset during a rewind.\r\n\r\n---\r\n\r\n### shortcuts\r\n\r\n*[OBJECT] Aliases for workflow queries*\r\n\r\nShortcuts are a way for you to reference a query by an alias instead of using it directly. This creates greater flexibility in your workflow by decoupling intention from expression. The shortcut name can be any arbitrary string, and you can define as many shortcuts as you want.\r\n\r\nFor example, say you sometimes want your workflow to go back to the beginning of the checkout process based on some query response. You can define a `checkout` shortcut like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    shortcuts : {\r\n        checkout : 'isCheckoutStarted'\r\n    }\r\n}\r\n```\r\n\r\nTo use the shortcut in your workflow, you would **reference it with an @ symbol**, like `@checkout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            then : 'isCheckoutCancelled'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    },\r\n    \r\n    isCheckoutCancelled : {\r\n        yes : {\r\n            then : '@checkout'\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBy using the shortcut, your workflow doesn't need to know which query is the starting query -- it just needs to know to go back to the query defined by `@checkout`. \r\n\r\nIf, in the future, you add additional queries to the beginning of your checkout flow, you only need to change the definition of the `checkout` shortcut in the config.\r\n\r\n#### @start\r\n\r\nYou can use any arbitrary string for a shortcut name, but there's one that has special meaning: **@start**. If you define a `start` shortcut, Turbine will use that as the first query to execute when Turbine is started.\r\n\r\n---\r\n\r\n### variables\r\n\r\n*[OBJECT] Keys representing scalar values (string, boolean, numeric, null)*\r\n\r\nAs you might expect, variables in Turbine work just like those in any programming language: the variable is replaced with the value defined in the config. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    variables : {\r\n        cartTimeout : 36000\r\n    }\r\n}\r\n```\r\n\r\nTo use the variable in your workflow, you would **reference it with an $ symbol**, like `$cartTimeout`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    isCheckoutStarted : {\r\n        yes : {\r\n            timeout : {\r\n                after : '$cartTimeout',\r\n                publish : 'Cart.timeout.expired',\r\n                then : 'stop.'\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe one caveat is that variables can only be used for string, boolean, numeric, or null values. If you want a variable-like way to represent object literals, use a mixin instead.\r\n\r\n---\r\n\r\n### mixins\r\n\r\n*[OBJECT] Keys representing object literals*\r\n\r\nA mixin is basically a variable representing an object literal. Mixins are replaced recursively, so you can use mixins within mixins. You can also use variables and shortcuts within mixins.\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    mixins : {\r\n        invalidLogin : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo use the mixin in your workflow, you would **reference it with a + symbol**, like `+invalidLogin`:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : '+invalidLogin',\r\n        PASSWORD_INCORRECT : '+invalidLogin',\r\n        CAPTCHA_INCORRECT  : '+invalidLogin'\r\n    }\r\n}\r\n```\r\n\r\nWhen Turbine imports your workflow, it replaces the mixins like this:\r\n\r\n```javascript\r\nworkflow : {\r\n    \r\n    whichError : {\r\n        USERNAME_NOT_FOUND : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        PASSWORD_INCORRECT : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        },\r\n        CAPTCHA_INCORRECT  : {\r\n            publish : {\r\n                message : 'Cart.login.failed'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFor a more complex implementation of mixins, see the example app in the /examples directory.\r\n\r\n---\r\n\r\n### always\r\n\r\n*[OBJECT]*\r\n\r\nThe `always` object is a way to define things that should be added to every query that is executed. This saves you from needing to duplicate the same code over and over. \r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    always : {\r\n        timeout : {},\r\n        waitFor : [],\r\n        using   : {}\r\n    }\r\n}\r\n```\r\n\r\n#### timeout  \r\nThe `timeout` property allows you to define a global timeout for the entire workflow. \r\n\r\nFor example, you may want to ask the user if they're still there when there has been no activity for a few minutes. Or you may want to raise an error if you app has become unresponsive for some reason. The format of the `timeout` property is the same as when  `timeout` is defined in a response (see [docs](#timeout-1) below).\r\n\r\n```javascript\r\ntimeout : {\r\n    after : 300000,\r\n    publish : {\r\n        message : \"Cart.issue.detected.GLOBAL_TIMEOUT\"\r\n    },\r\n    then : \"stop.\"\r\n},\r\n```\r\n\r\n#### waitFor\r\nThe `waitFor` property defines messages for which to listen, as well as an optional `then` that tells the workflow where to go when a message is received. Whenever your app is waiting for messages, these global `waitFor` messages will be listened for as well.\r\n\r\nThe format of the `waitFor` property is the same as when `waitFor` is defined in a response (see [docs](#waitfor-1) below).\r\n\r\n#### using\r\n\r\nThe `using` property is an object literal that will be merged with the `using` property whenever a message is published from Turbine.\r\n\r\n```javascript\r\nusing : {\r\n    timestamp : new Date().getTime()\r\n}\r\n```\r\n\r\n```javascript\r\nworkflow : {\r\n    isAppStarted : {\r\n        yes : {\r\n            publish : {\r\n                message : 'Cart.app.started',\r\n                using : {\r\n                    storeName : 'My Store'\r\n                }\r\n            }\r\n        },\r\n        no : {\r\n            // do stuff\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen this workflow runs and the `yes` response to `isAppStarted` is executed, Turbine will publish the `Cart.app.started` message. The message payload will be an object containing `storeName`, as well as `timestamp` from the global `using` object.\r\n\r\n---\r\n\r\n### init\r\n\r\n*[FUNCTION] Initialization function called at the end of the Turbine constructor*\r\n\r\nThe `init` function is an optional function that can be defined to be called once Turbine's constructor is complete. It is passed one argument: the Turbine instance that was just instantiated. This might be useful if you want your app to wait for Turbine to be fully instantiated before doing something.\r\n\r\n---\r\n\r\n### log\r\n\r\n*[FUNCTION] Custom logging function*\r\n\r\nBy default, Turbine outputs all its logs via the standard `console` methods: `log`, `warn`, and `error`. If you would rather send the logs to some other function, you can define it here and Turbine will use that instead.\r\n\r\nNote that log messages are only output by the non-minified Turbine.js. Logging is stripped out of the minified version to reduce file size.\r\n\r\n---\r\n\r\n### publish \r\n\r\n*[FUNCTION] Function to use when publishing events*\r\n\r\nBy default, Turbine will use `jQuery.trigger()` to publish events. If you would rather use some other event publishing method, such as `Backbone.Events.trigger()`, you can define that method here.\r\n\r\nTurbine will pass your `publish` method two arguments: \r\n\r\n* `message` *[String] Event to publish*\r\n* `payload` *[Object] Optional data object*\r\n\r\nYour events library may not be expecting those arguments, or in that order, so you may have to wrap your library's function in your own function that translates those arguments into something your library understands.\r\n\r\nFor example, maybe your fictional PubSub library requires a single object literal defining `event` and `data` instead of two arguments for `message` and `payload`. Then you might wrap it like this:\r\n\r\n```javascript\r\nvar initObj = {\r\n    \r\n    publish : function(message,payload){\r\n        \r\n        yourPubSub.trigger({\r\n            event : message,\r\n            data : payload\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### listen \r\n\r\n*[FUNCTION] Function to use when listening for events*\r\n\r\nBy default, Turbine will use `jQuery.on()` to listen for events. If you would rather use some other event listener, such as `Backbone.Events.on()`, you can define that method here.\r\n\r\nTurbine will pass your `listen` method two arguments: \r\n\r\n* `message` *[String] Event to listen for*\r\n* `handler` *[Function] Function to call when event is triggered*\r\n\r\nWhen the `handler` is triggered, it will be passed two arguments:\r\n\r\n* `message` *[String] Event that triggered the handler*\r\n* `payload` *[Object] Optional data object*\r\n\r\nLike `publish`, you may need to wrap your own event listener method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### remove \r\n\r\n*[FUNCTION] Function to use when removing event listeners*\r\n\r\nBy default, Turbine will use `jQuery.off()` to remove listeners. If you would rather use some other event library, such as `Backbone.Events.off()`, you can define that method here.\r\n\r\nTurbine will pass your `remove` method one argument: \r\n\r\n* `message` *[String] Event for which listeners should be removed*\r\n\r\nLike `publish` and `listen`, you may need to wrap your own method in a custom function to translate these arguments into something your listener understands.\r\n\r\n---\r\n\r\n### report\r\n\r\n*[FUNCTION] Function to use when reporting errors or events*\r\n\r\nBy default, Turbine will report any internal errors to the browser console via `console.error()`. \r\n\r\nIf you'd rather have issues reported through some event logging or analytics system, you can define your own custom `report` function here.\r\n\r\nTurbine will pass your `report` method one argument: \r\n\r\n* `obj` *[Object] Data object*\r\n\r\nIf an internal Turbine issue is being reported, this object will contain two properties:\r\n\r\n* `handle` Short string identifying the issue (WORKFLOW_ISSUE_REPORTED is the default)\r\n* `description` Human-readable description of the issue\r\n\r\nThe `report` function isn't just for errors though -- it can be used in the workflow to report any arbitrary event or activity. In this case, the data object passed to `report` is entirely defined in your workflow.\r\n\r\nFor example, say you have a `isUserBanned` query in your workflow. When a banned user tries to access your app, you want to report that activity to a security monitor. You might have this in your workflow:\r\n\r\n```javascript\r\n\r\nvar workflow = {\r\n        \r\n    isUserBanned : {\r\n        \r\n        yes : {\r\n            report : {\r\n                errorType : 'FATAL'\r\n                handle : 'BANNED_USER_LOGIN',\r\n                description : 'A banned user tried to log into the site',\r\n                username : app.getUserName()\r\n                timestamp : new Date().getTime()\r\n            },\r\n            then : 'stop.'\r\n        },\r\n        \r\n        no : {\r\n            then : 'isUserLoggedIn'\r\n        }\r\n    } \r\n};\r\n```\r\n\r\nYour `report` function would be passed whatever is defined in the workflow. You can then use that data to report the issue however your system requires.\r\n\r\n.\r\n\r\n## Elements of a workflow\r\n\r\nA workflow is an object literal defined in the init object passed to the Turbine constructor. It is the only mandatory property of the init object.\r\n\r\nThe workflow is essentially a dialog between Turbine and your app. Turbine executes a **query** and receives a **response**. That response tells Turbine what to do next, and which query to execute next.\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        // do something\r\n    },\r\n    no : {\r\n        // do something different\r\n    }\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n* `isUserLoggedIn` is the **query**\r\n* `yes` and `no` are the **responses**\r\n* The object literal values of the `yes` and `no` responses are the **response bodies**\r\n\r\n---\r\n\r\n### Queries\r\n\r\nWhen Turbine starts your workflow, it begins with the first query in the workflow (or the `@start` shortcut, if defined).\r\n\r\nTo get the response to the query, Turbine checks a few things:\r\n\r\n* Has a query function been set in `initObj.queries`? If so, Turbine executes the function and processes its response.\r\n* If there's no query function, has a response been set using `Turbine.setResponse()`? If so, Turbine uses that value.\r\n* If no response has been set, has any default response been set in `initObj.responses`? If so, Turbine uses that value.\r\n* If none of the above exist, then Turbine returns false and processes the \"no\" response.\r\n\r\n---\r\n\r\n### Responses\r\n\r\nResponses can be boolean, strings, or numbers. If a response is boolean, true is converted to \"yes\" and false is converted to \"no\". In addition, null and undefined responses are also converted to \"no\".\r\n\r\nA query's responses work similiarly to a JavaScript switch/case statement. If the value of the query's response matches any of the responses in the workflow, that response is processed.\r\n\r\nIn addition, there is the special **default** response. If `default` is defined, and the query's response doesn't match any of the responses defined in the workflow, Turbine will use the `default` response. \r\n\r\n```javascript\r\nwhichError : {\r\n    INVALID_EMAIL : {\r\n        // display invalid email error\r\n    },\r\n    INVALID_USERNAME : {\r\n        // display invalid username error\r\n    },\r\n    default : {\r\n        // display generic error\r\n    }\r\n}\r\n```\r\n\r\nIn this example, if the `whichError` query doesn't return either INVALID_EMAIL or INVALID_USERNAME, then the default response will be processed.\r\n\r\n---\r\n\r\n### Response bodies\r\n\r\nOnce a query has been executed and a response has been received, we need to know what to do next. This is expressed in the response body.\r\n\r\nWe'll get into details about all the things that can go into response bodies in a minute. For now, let's just focus on the most important property: `then`. \r\n\r\n#### then\r\n\r\nThe `then` property tells Turbine which query to execute next. When you see it in action, it's pretty self-explanatory:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\nTurbine's expressive workflow syntax makes it simple to see how the program will flow. For example:\r\n\r\n* Is the user logged in? Yes. Is the user over 18? Yes. Then let him in.\r\n* Is the user logged in? No. Does an account exist? No. Then ask the user to create one.\r\n* Is the user logged in? No. Does an account exist? Yes. Then ask the user to log in.\r\n* And so on ...\r\n\r\n##### `then` is always required (except when it's not)\r\n\r\nBecause `then` tells your workflow where to go next, it is required for every response body.\r\n\r\n(There's a slight caveat to that rule when using the `repeat` or `delay` property -- more on that later.)\r\n\r\nIf you leave `then` out, your app will basically freeze -- Turbine will get to the response that has no `then` in the response body, and it won't know where to go from there. Instead, it will throw an exception.\r\n\r\n##### Special values : `stop.` and `kill!`\r\n\r\nOf course, there will be times where your workflow really has no place else to go. In this case, you can set the value of `then` to either `stop.` or `kill!`. Using these special values allows your workflow to clearly indicate that it intends to stop.\r\n\r\nSetting `then` to `stop.` tells Turbine to stop. There are no ill effects -- you can restart Turbine later using `start()`, and it will start over from the beginning of the workflow.\r\n\r\nSetting `then` to `kill!` not only tells Turbine to stop, but it also prevents it from being started again. If you call `start()` after using `kill!`, Turbine will simply report an error.\r\n\r\n*Note that both `stop.` and `kill!` include punctuation -- that's required in order for Turbine to recognize them as special values.*\r\n\r\nContinuing to flesh out the example above, we can add `stop.` to `isUserOver18.no`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n    }\r\n}\r\n```\r\n\r\n#### publish\r\n\r\nTurbine is an event-driven workflow engine, so it communicates with your app by publishing messages from the workflow using the `publish` function defined in your initObj, or `jQuery.trigger()` by default.\r\n\r\nTo tell Turbine to publish a message, you define a `publish` object in the response body. This object has two properties: \r\n\r\n* `message` *[String or Array] The message to publish, or an array of messages to publish*\r\n* `using` *[Object] Optional data object to accompany published message*\r\n\r\nLet's publish some messages in our example:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        }\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOf course, publishing a message doesn't do much if there's nothing listening for it in your app. The expectation is that when your workflow publishes `App.view.show`, your app is listening for that message. Your app can then use the values from the `using` object to determine which view to show, and which content to use when showing it.\r\n\r\n#### waitFor\r\n\r\nIn the `isUserOver18` query above, both responses have `then : 'stop.'` in their response bodies. In those cases, after the workflow publishes its message, it's done. There's nothing left to do after the appropriate view is shown.\r\n\r\nBut what about in the `doesAccountExist` query? We want the user to either log in or create an account, so we published an `App.view.show` message from your workflow, your app was listening for it, it showed the view ... now what?\r\n\r\nWe need a way for the app to tell Turbine that it is done doing whatever it needed to do. For that, we use `waitFor`.\r\n\r\nThe `waitFor` property accepts either a message or array of messages for which Turbine should listen. Once Turbine receives a message it's waiting for, it continues where it left off, going wherever the `then` property tells it to go.\r\n\r\nLet's add some `waitFor` and `then` properties to the `doesAccountExist` response bodies. We'll also need to add two new queries: `isLoginValid` and `isAccountValid`:\r\n\r\n```javascript\r\nisUserLoggedIn : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        then : 'doesAccountExist'\r\n    }\r\n},\r\n\r\nisUserOver18 : {\r\n    yes : {\r\n        // let the user in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'loginAccepted',\r\n                content : 'ENTRY_ACCEPTED'\r\n            }\r\n        },\r\n        then : 'stop.'\r\n    },\r\n    no : {\r\n        // don't let the user in\r\n        publish : {\r\n            message : [\r\n                'User.age.rejected', \r\n                'App.view.show'\r\n            ],\r\n            using : {\r\n                view : 'loginRejected',\r\n                content : 'NOT_OLD_ENOUGH'\r\n            }\r\n        }\r\n        then : 'stop.'\r\n    }\r\n},\r\n\r\ndoesAccountExist : {\r\n    yes : {\r\n        // make the user log in\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'logIn'\r\n            }\r\n        },\r\n        waitFor : 'App.login.submitted',\r\n        then : 'isLoginValid'\r\n    },\r\n    no : {\r\n        // ask the user to create an account\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'createAccount'\r\n            }\r\n        },\r\n        waitFor : 'App.account.created',\r\n        then : 'isAccountValid'\r\n    }\r\n},\r\n\r\nisLoginValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n},\r\n\r\nisAccountValid : {\r\n    yes : {\r\n        then : 'isUserOver18'\r\n    },\r\n    no : {\r\n        // show login error\r\n    }\r\n}\r\n```\r\n\r\nLet's assume our user has an account, so we showed him a login form. When that form is submitted, your app publishes a `App.login.submitted` message. Since Turbine is waiting for that message, it follows then `then` property to `isLoginValid`.\r\n\r\n##### Multiple `then` options\r\n\r\nSometimes you might want your app to execute a different query depending on which `waitFor` message it receives. To do this, you can specify `waitFor` as an object or array of objects containing two properties:\r\n\r\n* `message` *[String or Array] The message to wait for, or an array of messages to wait for*\r\n* `then` *[String] Query to execute when one of the messages is received*\r\n\r\nFor example:\r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ]\r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n},\r\n\r\nisOldEnough : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n\r\nisHelpLoaded : {\r\n    yes : {\r\n        // show Help\r\n    },\r\n    no : {\r\n        // load Help\r\n    }\r\n}\r\n```\r\n\r\nIf you specify a `then` to accompany a `waitFor` message, it will **override** any `then` that is specified outside `waitFor`. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO'],\r\n                then : 'isOldEnough'\r\n            },\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isLoggedIn' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isLoggedIn` will never be executed, because each `waitFor` message has its own `then` property.\r\n\r\nHowever, if you don't specify a `then` to accompany a `waitFor` message, the `then` that is specified outside `waitFor` will be used. \r\n\r\n```javascript\r\nisAgeGateRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'ageGate',\r\n                content : 'Are you over 18?'\r\n            }\r\n        },\r\n        waitFor : [\r\n            {\r\n                message : ['App.button.clicked.YES','App.button.clicked.NO']\r\n            }\r\n            {\r\n                message : 'App.button.clicked.HELP',\r\n                then : 'isHelpLoaded'\r\n            }\r\n        ],\r\n        then : 'isOldEnough' \r\n    },\r\n    no : {\r\n        // do stuff\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, the `App.button.clicked.YES` and `App.button.clicked.NO` will execute `isOldEnough` next, whereas `App.button.clicked.HELP` will execute `isHelpLoaded`. \r\n\r\nWhile this approach technically will work, it is not recommended -- if you're using multiple `then` options, then each `waitFor` message really should have its own `then`, for clarity's sake.\r\n\r\n#### repeat\r\n\r\nSometimes you may want to repeat the same query over and over again, such as when you are polling a server for a particular response. To do this, you add a `repeat` object in the response body. \r\n\r\nThe `repeat` object is used in lieu of `then` -- by using `repeat`, you are implicitly saying \"execute this query, *then* execute this query again\".\r\n\r\nThe `repeat` object contains one required property:\r\n\r\n* `limit` *[Number or null] The maximum times the query will be repeated. If null, the query will repeat infinitely.*\r\n\r\nIn addition, the `repeat` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the limit is reached, the `repeat` object is processed as a response body.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine waits for an `App.upload.updated` message. When it gets one, it repeats the `isUploadComplete` query. If the response is still `no`, then it again waits for `App.upload.updated`.\r\n\r\nThis continues until `isUploadComplete` is `yes`, or the query repeats 100 times. If the limit is reached, then Turbine executes the repeat object as a response body, publishing `App.upload.failed` and then stopping.\r\n\r\n#### timeout\r\n\r\nOne of the drawbacks of an event-driven workflow engine is that if it's waiting for a message that never comes, it is basically stuck. To help avoid that situation, a `timeout` object is available.\r\n\r\nThe `timeout` object allows you to specify an alternate response body to process after a certain amount of time elapses. It contains one required property:\r\n\r\n* `after` *[Number] The number of milliseconds after which the timeout will fire*\r\n\r\nIn addition, the `timeout` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. If the timeout is exceeded, the `timeout` object is processed as a response body.\r\n\r\n```javascript\r\nisTransactionComplete : {\r\n    no : {\r\n        waitFor : 'App.transaction.completed',\r\n        timeout : {\r\n            after : 300000,\r\n            publish : {\r\n                message : 'App.transaction.failed',\r\n                using : {\r\n                    reason : 'TIMEOUT_EXCEEDED'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        },\r\n        then : 'isTransactionComplete'\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, Turbine is waiting for an `App.transaction.complete` message. If it doesn't receive it after 300000 milliseconds (5 mins), it publishes an `App.transaction.failed` message, then stops.\r\n\r\nNotice that the `no` response body still has its own `then` value -- that is required so Turbine knows where to go if it *does* receive the `App.transaction.complete` message before the timeout.\r\n\r\n#### delay\r\n\r\nSometimes you may want to wait a little while before processing a response body. For example, say you're using Turbine to prototype a loading screen -- you might want to add a 3-second delay, then publish a message to move to the next screen. That's where the `delay` object is useful.\r\n\r\nThe `delay` object is used in lieu of `then` -- by using `delay`, you are implicitly saying \"wait for a while, *then* process the delayed response\".\r\n\r\nThe `delay` object contains one required property:\r\n\r\n* `for` *[Number] The number of milliseconds to wait before processing the delayed response body*\r\n\r\nIn addition, the `delay` object can contain anything that a response body can contain: `publish`, `waitFor`, `then`, etc. After the delay elapses, the `delay` object is processed as a response body.\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\nIn the example above, `isAppLoaded` gets a `no` response. Turbine waits for 3000 ms (3 seconds), publishes the `App.view.show` message, then stops.\r\n\r\nNote that `delay` doesn't have to live alone in the response body. It can co-exist with other properties as well. For example:\r\n\r\n```javascript\r\nisAppLoaded : {\r\n    no : {\r\n        publish : {\r\n            message : 'App.view.show',\r\n            using : {\r\n                view : 'appLoading'\r\n            }\r\n        },\r\n        delay : {\r\n            for : 3000,\r\n            publish : {\r\n                message : 'App.view.show',\r\n                using : {\r\n                    view : 'appLoaded'\r\n                }\r\n            },\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Loaded message\r\n    }\r\n}\r\n```\r\n\r\n#### report\r\n\r\nIn many ways, Turbine is just a big state machine. As such, it is a centralized mechanism for monitoring the state of your application. If your application is in a state that is worth reporting, you can define `report` in your response body.\r\n\r\nThe value of `report` can be anything you want: a string, an object, an array, etc.\r\n\r\nBy default, `report` just passes its value to `console.error()`. However, you can define your own custom `report` function in initObj, allowing you to send reports to Google Analytics, Omniture, or whatever your preferred analytics tool may be.\r\n\r\nConsider the example we used for `repeat` earlier. We checked 100 times whether the upload was complete, and it never was. That's the sort of thing you might want to report.\r\n\r\n```javascript\r\nisUploadComplete : {\r\n    no : {\r\n        waitFor : 'App.upload.updated',\r\n        repeat : {\r\n            limit : 100,\r\n            publish : {\r\n                message : 'App.upload.failed',\r\n                using : {\r\n                    reason : 'UPLOAD_CHECK_LIMIT_EXCEEDED'\r\n                }\r\n            },\r\n            report : 'APP_UPLOAD_FAILURE',\r\n            then :  'stop.'\r\n        }\r\n    },\r\n    yes : {\r\n        // display Done message\r\n    }\r\n}\r\n```\r\n\r\nNow `APP_UPLOAD_FAILURE` will be sent to your reporting system so you can investigate why it failed.\r\n\r\n## API\r\n\r\nThe Turbine API is extremely simple -- most of the logic and complexity is implemented in the workflow itself. There are just a few methods available:\r\n\r\n---\r\n### start()\r\n\r\nOnce an instance of Turbine has been created, calling `start()` will actually start the workflow.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.start();\r\n```\r\n\r\nYou can also chain `start()` directly to the new Turbine instance, if you want it to start right away:\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj).start();\r\n```\r\n\r\n---\r\n### isStarted()\r\n\r\nIf you want to know whether Turbine has been started, you can use `isStarted()`.\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\n```\r\n\r\n---\r\n### stop()\r\n\r\nTo stop Turbine, simple call stop().\r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.isStarted(); // returns false\r\nturbine.start();\r\nturbine.isStarted(); // returns true\r\nturbine.<span class="apidocCodeKeywordSpan">stop</span>();\r\nturbine.isStarted(); // returns false\r\n```\r\n\r\n---\r\n### getVar(varName)\r\n\r\nThe `getVar()` method retrieves the value of the variable set in Turbine's init object.\r\n\r\n* `varName` *[String] The name of the variable to retrieve* \r\n\r\n```javascript\r\nvar initObj = {\r\n    variables : {\r\n        maxRetries : 100\r\n    }\r\n};\r\n\r\nvar turbine = new Turbine(initObj);\r\nturbine.getVar('maxRetries'); // returns 100\r\n```\r\n\r\n---\r\n### setResponse(query, response)\r\n\r\nThe `setResponse` method sets the response to a query.\r\n\r\n* `query` *[String] The query to set the response for* \r\n* `response` *[String or Number or Boolean] The response to the query* \r\n\r\n```javascript\r\nvar turbine = new Turbine(initObj);\r\nturbine.setResponse('isLoggedIn',true);\r\n```\r\n\r\n## Examples\r\n\r\nInside the /examples directory, you'll find a sample app that uses most of the concepts described in these docs. \r\n\r\nJust open /examples/index.html in a browser, select which type of workflow you want to load, then click Start Turbine. \r\n\r\nThe app has a simple list of products, along with a mock shopping cart. You can add and remove items in the cart, do a simulated login and signup, and execute a mock checkout.\r\n\r\nSome things to try: \r\n\r\n### When login is required before adding an item to the cart\r\n\r\n* Try adding an item without logging in. You'll be prompted to log in. Click the Log In button, then try adding the item again. You'll be able to add it now.\r\n* If you try adding an item 3 times without logging in, you'll be forced to sign up.\r\n* If you add a PlayStation and NBA 2K13, you'll get a discount.\r\n* If, during signup, you select Male and Basketball, you'll get bonus SuperShopper points.\r\n\r\n### When login is required before checkout\r\n* You can add items to the cart immediately\r\n* If you add a PlayStation and wait a few seconds, you'll be prompted to add a DualShock controller.\r\n* If you add a DualShock, you'll be prompted to add a charging station.\r\n* If you try to check out without logging in, you'll be prompted to log in first.\r\n\r\nTo see how this all fits together as workflows, check out /examples/js/init.js. There you'll find the initObj that sets up the workflows.\r\n\r\n**IMPORTANT NOTE:** This example app is meant to show how to implement Turbine and its workflows. It is *not* a good example of how to actually write a web app. There's some kludgy code, there's HTML commingled in the JavaScript, etc. It's pretty gross.\r\n\r\n## FAQ\r\n\r\n### Can I chain or nest multiple workflows together?\r\n\r\nSure. As a matter of fact, the signup flow in the example app is a separate workflow from the shopping cart flow. Take a look.\r\n\r\nFirst, instantiate an instance of Turbine and start it up. When you get to the part of the workflow where you want to kick off another workflow, publish a message that tells your app to start the other workflow, then wait for a message that lets you know when the other workflow is done.\r\n\r\nFor example, your first workflow might have:\r\n\r\n```javascript\r\nisSignupRequired : {\r\n    yes : {\r\n        publish : {\r\n            message : 'App.signup.start'\r\n        },\r\n        waitFor : 'App.signup.complete',\r\n        then : 'isSignupValid'\r\n    },\r\n    no : {\r\n        // let them in\r\n    }\r\n}\r\nisSignupValid : {\r\n    yes : {\r\n        // let them in\r\n    },\r\n    no : {\r\n        // don't let them in\r\n    }\r\n}\r\n```\r\n\r\nYour app can listen for `App.signup.start`. When it receives that message, it creates a new Turbine instance for the signup workflow. When that workflow is complete, it publishes `App.signup.complete`. Since the first workflow is waiting for that message, it will execute the `isSignupValid` query. *Voila!* Nested workflows!\r\n\r\n## Questions? Bugs? Suggestions?\r\n\r\nPlease submit all bugs, questions, and suggestions via the [Issues](https://github.com/wmbenedetto/turbine.js/issues) section so everyone can benefit from the answer.\r\n\r\nIf you need to contact me directly, email warren@transfusionmedia.com.\r\n\r\n## MIT License\r\n\r\nCopyright (c) 2012 Warren Benedetto &lt;warren@transfusionmedia.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
"readmeFilename": "README.md",
"repositories": [
  {
    "type": "git",
    "url": "git+https://github.com/wmbenedetto/turbine.js.git"
  }
],
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.turbine.js.Turbine.prototype.utils" id="apidoc.module.turbine.js.Turbine.prototype.utils">module turbine.js.Turbine.prototype.utils</a></h1>


    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.utils.inArray" id="apidoc.element.turbine.js.Turbine.prototype.utils.inArray">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>inArray
        <span class="apidocSignatureSpan">(item, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inArray = function (item, source) {

    for (var i=0;i&lt;source.length;i++) {

        if (item === source[i]) {
            return true;
        }
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    testInArray : function(){

var turbine = new Turbine(this.initObj);

var source = ['foo','bar','baz'];

assertTrue('"foo" exists in array',turbine.utils.<span class="apidocCodeKeywordSpan">inArray</span>('foo
',source));
assertFalse('"nope" doesn\'t exist in array',turbine.utils.inArray('nope',source));
    },

    testIsObjLiteral : function(){

var turbine = new Turbine(this.initObj);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.utils.isArray" id="apidoc.element.turbine.js.Turbine.prototype.utils.isArray">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        /**
         * Imports sequence
         *
         * @param initObj Initialization object
         */
        importSequence : function(initObj) {

            if (this.utils.<span class="apidocCodeKeywordSpan">isArray</span>(initObj.sequence)) {

if (!MINIFIED){
    this.log('importSequence', 'Importing sequence', null, 'DEBUG');
}

initObj.sequence                = initObj.sequence || [];
initObj.workflow                = this.importSequenceQueries(initObj.sequence);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.utils.isObjLiteral" id="apidoc.element.turbine.js.Turbine.prototype.utils.isObjLiteral">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>isObjLiteral
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObjLiteral = function (obj) {
    return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; !this.isArray(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        thisObj                         = validObjects[i];

        if (!MINIFIED){
            this.log('importObjects', '--&gt; Importing ' + thisObj + ' object', null, 'DEBUG
');
        }

        if (this.utils.<span class="apidocCodeKeywordSpan">isObjLiteral</span>(initObj[thisObj])) {
            this[thisObj]               = initObj[thisObj];
        }
    }
},

/**
 * Imports workflow
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.utils.mergeObjects" id="apidoc.element.turbine.js.Turbine.prototype.utils.mergeObjects">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>mergeObjects
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeObjects = function (target, source) {

    for (var i in source) {

        if (source.hasOwnProperty(i)) {

            if ((typeof target[i] === 'object' &amp;&amp; target[i] !== null) &amp;&amp; (typeof source[i] === 'object' &amp;&amp; source[i] !== null)) {

                target[i]           = this.mergeObjects(target[i],source[i]);

            } else {

                target[i]           = source[i];
            }
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         */
        getUsingObject : function(using) {

using                               = (typeof using === 'undefined') ? {} : using;

/* If an always.using object has been defined, merge it into the response's using object */
if (this.always.using) {
    using                           = this.utils.<span class="apidocCodeKeywordSpan">mergeObjects</span>(using,this.always.using
);
}

if (!MINIFIED){
    this.log('getUsingObject', 'Getting using object', using, 'TRACE');
}

return using;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.turbine.js.Turbine.prototype.utils.traverseObj" id="apidoc.element.turbine.js.Turbine.prototype.utils.traverseObj">
        function <span class="apidocSignatureSpan">turbine.js.Turbine.prototype.utils.</span>traverseObj
        <span class="apidocSignatureSpan">(obj, depth, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseObj = function (obj, depth, callback) {

    // start at level 0
    depth           = depth || 0;
    callback        = callback || null;

    for (var item in obj) {

        // if we find a child object
        if (obj.hasOwnProperty(item) &amp;&amp; typeof obj[item] === 'object') {

            // recursively call myself again to loop through the child object
            // "this" refers to "this.utils"
            this.traverseObj(obj[item], ++depth, callback);

        } else if (callback) {

            callback(obj, item);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                var query                       = sequence[i];
                var currentStepCount            = i + 1;

                (function(q,c){

/* Rewrite every instance of "then" in the query objects */
self.utils.<span class="apidocCodeKeywordSpan">traverseObj</span>(q, 0, function(obj, item) {

    /* Replace "@next" with the name of the next query (or with "stop." if it's the last query) */
    if (item === 'then' &amp;&amp; obj[item] === '@next') {
        var nextStepCount   = c + 1;
        obj[item]           = (nextStepCount &gt; sequence.length) ? 'stop.' : stepBaseName + nextStepCount;
    }
});
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>